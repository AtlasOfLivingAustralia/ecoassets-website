[
  {
    "objectID": "posts/first-news-post/post.html",
    "href": "posts/first-news-post/post.html",
    "title": "EcoAssets 2024 is up and running",
    "section": "",
    "text": "News Post 0\nThis is a test news post.\nExciting news! EcoAssets Quarto website has launched!\n\n\n\n\n Back to top"
  },
  {
    "objectID": "homepage.html",
    "href": "homepage.html",
    "title": "homepage",
    "section": "",
    "text": "&lt;!DOCTYPE html&gt;\n\n\n\n  \n\n\n\n\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"overlap-group\"&gt;\n    &lt;div class=\"rectangle\"&gt;&lt;/div&gt;\n    &lt;div class=\"text-wrapper\"&gt;Copyright&lt;/div&gt;\n    &lt;div class=\"text-wrapper-2\"&gt;Terms of use&lt;/div&gt;\n    &lt;div class=\"text-wrapper-3\"&gt;Privacy policy&lt;/div&gt;\n    &lt;div class=\"rectangle-2\"&gt;&lt;/div&gt;\n    &lt;p class=\"ecoassets-received\"&gt;\n      &lt;span class=\"span\"&gt;EcoAssets received investment (&lt;/span&gt;\n      &lt;a href=\"https://doi.org/10.47486/XN005\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"span\"&gt;doi.org/10.47486/XN005&lt;/span&gt;&lt;/a&gt;\n      &lt;span class=\"span\"&gt;) from the Australian Research Data Commons (ARDC). The ARDC is funded by the Australian Research Data\n        National Collaborative Research Infrastructure Strategy (NCRIS).&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;div class=\"frame\"&gt;\n      &lt;div class=\"logos\"&gt;\n        &lt;img class=\"img\" src=\"img/rectangle-10.png\" /&gt;\n        &lt;img class=\"rectangle-3\" src=\"img/rectangle-11.png\" /&gt;\n        &lt;img class=\"rectangle-4\" src=\"img/rectangle-12.png\" /&gt;\n        &lt;img class=\"rectangle-5\" src=\"img/rectangle-13.png\" /&gt;\n        &lt;img class=\"rectangle-6\" src=\"img/rectangle-14.png\" /&gt;\n        &lt;img class=\"rectangle-7\" src=\"img/rectangle-15.png\" /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;p class=\"acknowledgement-of\"&gt;\n      &lt;span class=\"text-wrapper-4\"&gt;Acknowledgement of Traditional Owners and Country&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-5\"\n        &gt;&lt;br /&gt;The project partners acknowledge Australia’s Traditional Owners and pay respect to the past and\n        present Elders of the nation’s Aboriginal and Torres Strait Islander communities. We honour and\n        celebrate the spiritual, cultural and customary connections of Traditional Owners to the country and the\n        biodiversity that forms part of that country.&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;img class=\"line\" src=\"img/line-1.svg\" /&gt;\n  &lt;/div&gt;\n  &lt;div class=\"rectangle-8\"&gt;&lt;/div&gt;\n&lt;/footer&gt;\n&lt;div class=\"news\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;News&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"&gt;View latest updates &gt; &lt;/span&gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"data\"&gt;\n  &lt;div class=\"explore-data-explore-wrapper\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Explore Data&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;Explore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and\n        TERN.&lt;br /&gt;&lt;br /&gt;See data &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"welcome\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Welcome to EcoAssets&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;EcoAssets brings together environmental data collected from three national research infrastructures –\n        the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the\n        information can be streamlined into integrated data assets to support Australia&#39;s environmental\n        reporting needs.&lt;br /&gt;&lt;br /&gt;Learn more &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;header class=\"header\"&gt;\n  &lt;div class=\"overlap-2\"&gt;\n    &lt;div class=\"title-background\"&gt;\n      &lt;div class=\"div-wrapper\"&gt;&lt;div class=\"text-wrapper-9\"&gt;EcoAssets&lt;/div&gt;&lt;/div&gt;\n      &lt;div class=\"rectangle-9\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"nav-bar\"&gt;\n      &lt;div class=\"overlap-3\"&gt;\n        &lt;div class=\"text-wrapper-10\"&gt;About&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"overlap-4\"&gt;\n        &lt;div class=\"text-wrapper-11\"&gt;Data&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down-2\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"text-wrapper-12\"&gt;News&lt;/div&gt;\n      &lt;img class=\"fi-bs-search\" src=\"img/fi-bs-search.svg\" /&gt;\n      &lt;img class=\"fi-bs-home\" src=\"img/fi-bs-home.svg\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/header&gt;\n&lt;img class=\"main-image\" src=\"img/main-image.png\" /&gt;"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About EcoAssets",
    "section": "",
    "text": "EcoAssets is improving access to integrated environmental data in forms that can support national, and state and territory environmental assessment and reporting activities. The project was established to support the authors of the 2021 Federal State of the Environment (SoE) report which reviews how different pressures are changing Australia’s land and marine environments and how these changes will impact the economy and society.\nAustralian environmental research infrastructures and their data partners collect large amounts of data each year on all aspects of the environment. In the past these data have not been integrated across infrastructures, or provided at a scale and in a format suitable for environmental reporting at national, or state and territory levels.\nThrough EcoAssets, three of Australia’s national research infrastructures - the ALA, IMOS and TERN - are working together to deliver open integrated data to support environmental assessment and reporting needs.\nThe key resulting data assets are: Integrated species distribution data asset Integrated survey and monitoring activity data asset EcoAssets is achieving these outcomes by identifying opportunities to increase alignment between data from all partners. In particular, we are simplifying spatiotemporal analyses and addressing differences in terminology and vocabularies."
  },
  {
    "objectID": "about.html#core-features",
    "href": "about.html#core-features",
    "title": "About EcoAssets",
    "section": "Core Features",
    "text": "Core Features\n\nImprovements to Data Pipelines\nEcoAssets will develop pipelines that offer standard views of the biodiversity component of data collected during TERN and IMOS field programmes for aggregation with ALA data streams.\n\n\nAggregation of Similar Data\nPartners will deliver and maintain high-value national data products that will serve as reference assets and a baseline for future environmental assessment. Data assets include species distribution, monitoring activity and growth in biodiversity knowledge. \n\n\nAlignment of Data Services\nThe newly aggregated data assets will provide a single set of data for major environmental products from the NCRIS infrastructures. This collection will feature standardised metadata, spatial and temporal units and other facets to support SoE reporting. The data assets will add significant value to future SoE reports (produced every 5 years), and other areas such as environmental accounting and impact assessments. \n\n\nData Principles: Findable, Accessible, Interoperable and Reusable (FAIR)\nData linkages and summary formats will provide easy-to-access information on indicators and trends. Data pipelines developed will enable future continuous updates and integration of new data from partners."
  },
  {
    "objectID": "about.html#partners",
    "href": "about.html#partners",
    "title": "About EcoAssets",
    "section": "Partners",
    "text": "Partners\n\n\n\n\n\nAtlas of Living Australia (ALA)\nThe Atlas of Living Australia (ALA) aggregates evidence of the distribution of Australian plant and animal species, bringing together data from museum specimens, field surveys, citizen science observations, molecular sequencing and literature. There are currently over 101 million freely available records held in the ALA.\n\n\n\n\n\nIntegrated Marine Observing System (IMOS)\nThe Integrated Marine Observing System (IMOS) operates a wide range of observing equipment throughout Australia’s coastal and open oceans, covering physical, chemical and biological variables. IMOS provides over 950 million freely available recorded ocean measurements.\n\n\n\n\n\nTerrestrial Ecosystem Research Network (TERN)\nTERN Australia advances research on anthropogenic impacts on land-based Australian ecosystems through provision of open access, standardised and integrated time-series data from its remote sensing, field observation and sensor monitoring across the continent. NCRIS\n\n\n\n\n\nAustralian Research Data Commons (ARDC)\nThe Australian Research Data Commons (ARDC) enables the Australian research community and industry access to nationally significant, data-intensive digital research infrastructure, platforms, skills and collections of high-quality data. The EcoAssets project received investment (https://doi.org/10.47486/XN005) from Australian Research Data Commons (ARDC), funded by The National Collaborative Research Infrastructure Strategy (NCRIS).\n\n\n\n\n\nAustralian Government\nDelivering the State of the Environment Report every five years, the Australian Government oversees national environmental interests in a broad range of areas such as environment and heritage, water resources, biosecurity, agriculture and the Antarctic.\n\n\n\n\n\n\n\n\nThe National Collaborative Research Infrastructure Strategy (NCRIS)\nThe ALA, IMOS, TERN and ARDC are made possible with funding from The National Collaborative Research Infrastructure Strategy (NCRIS)."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "About the Data",
    "section": "",
    "text": "EcoAssets Data explained\n1-2 sentences explaining the EcoAssets data, the difference between the datasets etc.\nlink to biodiversity page and monitoring page from here.\n\n100 + 10"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to EcoAssets",
    "section": "",
    "text": "Golden Stag Beetle"
  },
  {
    "objectID": "index.html#welcome-to-ecoassets",
    "href": "index.html#welcome-to-ecoassets",
    "title": "EcoAssets",
    "section": "Welcome to EcoAssets",
    "text": "Welcome to EcoAssets\nEcoAssets brings together environmental data collected from three national research infrastructures – the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the information can be streamlined into integrated data assets to support Australia’s environmental reporting needs.\nLearn more &gt;"
  },
  {
    "objectID": "index.html#explore-data",
    "href": "index.html#explore-data",
    "title": "EcoAssets",
    "section": "Explore Data",
    "text": "Explore Data\nExplore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and TERN.\nSee data &gt;"
  },
  {
    "objectID": "index.html#news",
    "href": "index.html#news",
    "title": "EcoAssets",
    "section": "News",
    "text": "News\n\n\n\n\n\n\n\n\nEcoAssets 2024 is up and running\n\n\nThe first news post of the website.\n\n\n\nClara Peers\n\n\nApr 1, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n\nView latest updates &gt;"
  },
  {
    "objectID": "news.html",
    "href": "news.html",
    "title": "News",
    "section": "",
    "text": "EcoAssets 2024 is up and running\n\n\nThe first news post of the website.\n\n\n\nClara Peers\n\n\nApr 1, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html#about-us",
    "href": "about.html#about-us",
    "title": "About EcoAssets",
    "section": "",
    "text": "EcoAssets is improving access to integrated environmental data in forms that can support national, and state and territory environmental assessment and reporting activities. The project was established to support the authors of the 2021 Federal State of the Environment (SoE) report which reviews how different pressures are changing Australia’s land and marine environments and how these changes will impact the economy and society.\nAustralian environmental research infrastructures and their data partners collect large amounts of data each year on all aspects of the environment. In the past these data have not been integrated across infrastructures, or provided at a scale and in a format suitable for environmental reporting at national, or state and territory levels.\nThrough EcoAssets, three of Australia’s national research infrastructures - the ALA, IMOS and TERN - are working together to deliver open integrated data to support environmental assessment and reporting needs.\nThe key resulting data assets are: Integrated species distribution data asset Integrated survey and monitoring activity data asset EcoAssets is achieving these outcomes by identifying opportunities to increase alignment between data from all partners. In particular, we are simplifying spatiotemporal analyses and addressing differences in terminology and vocabularies."
  },
  {
    "objectID": "biodiversity_data.html#info-2",
    "href": "biodiversity_data.html#info-2",
    "title": "EcoAssets",
    "section": "info 2",
    "text": "info 2"
  },
  {
    "objectID": "biodiversity_data.html#info-3",
    "href": "biodiversity_data.html#info-3",
    "title": "EcoAssets",
    "section": "info 3",
    "text": "info 3"
  },
  {
    "objectID": "biodiversity_data.html",
    "href": "biodiversity_data.html",
    "title": "EcoAssets",
    "section": "",
    "text": "Figure 1\n\n`Threatened Status of species from the year ${selectedYear} to the year ${selectedYearEnd}`\n\n\n\n\n\n\n\nimcraData = FileAttachment(\"data/SummaryData-ThreatenedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\nibraData = FileAttachment(\"data/SummaryData-ThreatenedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\n\ncombinedData = Promise.all(\n  [imcraData,\n  ibraData]\n).then(\n  ([data1, data2]) =&gt; {\n    return data1.concat(data2)\n  }\n)\n\nPlot.plot({\n  color: { legend: true, scheme: \"Rainbow\" },\n  marks: [\n    Plot.barY(\n      year,\n      Plot.groupX(\n        { y: \"count\" },\n        { x: \"epbcStatus\", fill: \"epbcStatus\", tip: true }\n      )\n    ),\n    Plot.ruleY([0])\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof year = Inputs.radio(d3.group(combinedData, d =&gt; d.yearStart), {label: \"Year\", sort: \"ascending\", value:'2016'})\n\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nselectedYear = year[0][\"yearStart\"]\n\nselectedYearEnd = year[0][\"yearEnd\"]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTime-out error: WARNING: error writing a body to connection: An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. (os error 10055): An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. (os error 10055)\n\n\nFigure 2\n\n\nLink to access data\nLink to CSIRO data portal to access data."
  },
  {
    "objectID": "biodiversity_data.html#figure-1",
    "href": "biodiversity_data.html#figure-1",
    "title": "EcoAssets",
    "section": "",
    "text": "imcraData = FileAttachment(\"SummaryData-ThreatenedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\nibraData = FileAttachment(\"SummaryData-ThreatenedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\n\ncombinedData = Promise.all(\n  [imcraData,\n  ibraData]\n).then(\n  ([data1, data2]) =&gt; {\n    return data1.concat(data2)\n  }\n)\n\nPlot.plot({\n  color: { legend: true, scheme: \"Rainbow\" },\n  marks: [\n    Plot.barY(\n      year,\n      Plot.groupX(\n        { y: \"count\" },\n        { x: \"epbcStatus\", fill: \"epbcStatus\", tip: true }\n      )\n    ),\n    Plot.ruleY([0])\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof year = Inputs.radio(d3.group(combinedData, d =&gt; d.yearStart), {label: \"Year\", sort: \"ascending\", value:[498]})\n\nselectedYear = year[0][\"yearStart\"]\n\nselectedYearEnd = year[0][\"yearEnd\"]"
  },
  {
    "objectID": "biodiversity_data.html#figure-2",
    "href": "biodiversity_data.html#figure-2",
    "title": "EcoAssets",
    "section": "Figure 2",
    "text": "Figure 2"
  },
  {
    "objectID": "monitoring_data.html",
    "href": "monitoring_data.html",
    "title": "EcoAssets",
    "section": "",
    "text": "Visualisations\nMonitoring data viz here, with explanation.\n\n\nLink to Access Data\nLink to CSIRO data portal to access monitoring dataset."
  },
  {
    "objectID": "dataStory0.html",
    "href": "dataStory0.html",
    "title": "Data Story 0",
    "section": "",
    "text": "As demo’ed here : https://github.com/jimjam-slam/quarto-experiments/blob/main/scrollytelling/index.qmd.\n\n\nThis\nis\na\nlong\ncolumn\nof text\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nv\ne\nr\ny\nl\no\nn\ng\n.\n\n\n\nThis whole column has position:sticky; and top:100px on it!\n\nFIGURE\n\n\n\n\n\n\n\n\nA beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "dataStory0.html#demo-sticky-overlay",
    "href": "dataStory0.html#demo-sticky-overlay",
    "title": "Data Story 0",
    "section": "",
    "text": "A beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "d3Chart.html",
    "href": "d3Chart.html",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "d3Chart.html#a-d3-chart",
    "href": "d3Chart.html#a-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "d3Chart.html#an-interactive-seal",
    "href": "d3Chart.html#an-interactive-seal",
    "title": "A custom d3 visualisation",
    "section": "An interactive Seal",
    "text": "An interactive Seal\nThis was made with: https://robisateam.github.io/courses/web-course/5-javascript\n\n  \n\n\nFeed\nSwim\n\nseal_image = document.getElementById('seal');\nfeed_button = document.getElementById('feed-button')\nswim_button = document.getElementById('swim-button')\n\n// detect if someone clicks on the image -&gt; event listeners constantly check if someone performs a certain action\n// event listener takes 2 args: the type of event and a callback\n// callback: a function that explains what we want it to do when the event fires -&gt; in this case, execute a function called cricket\n//beetle_image.addEventListener(\"click\", cricket);\n\nfunction roar() {\n  alert(\"roooaaaaar\");\n};\n\n// create an inline function to execute a sequence of functions -&gt; only defined in the scope of this specific callback\nseal_image.addEventListener(\"click\", function() {\n  roar();\n  //scratch();\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfeed_button.addEventListener(\"click\", feed);\n\n\n\n\n\n\n\nfunction feed() {\n  seal_image.style.height = (seal_image.offsetHeight + 30.0) + 'px';\n};\nswim_button.addEventListener(\"dblclick\", function() {\n  seal_image.style.height = (seal_image.offsetHeight - 30.0) + 'px'\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = [10, 20, 30];\nconsole.log(data);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_object0 = ({name:\"cat\", weight: 10});\ncat_object = ({weight : 5, past_weight_values : 5, name : \"Princess Caroline\"});\n\ncat_list = [cat_object]; // initializing with the first field being cat_object\ncat_list.push({weight : 6 , past_weight_values : [5.9, 5.3, 6.1], name : \"Snowball\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_list.push({weight : 2})\n\n\n\n\n\n\n\nconsole.log(cat_list)"
  },
  {
    "objectID": "d3Chart.html#another-d3-chart",
    "href": "d3Chart.html#another-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "Another D3 Chart",
    "text": "Another D3 Chart\nFrom this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n////////////////////// Set up Chart\n\n\n////////////////////// Create Axes\n\n\n////////////////////// Plot Data \n\nPlot.plot({\n  width: 300,\n  height: 240,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 20] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      currentData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html",
    "href": "d3Chart2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#another-d3-chart",
    "href": "d3Chart2.html#another-d3-chart",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n////////////////////// Set up Chart\n\n\n////////////////////// Create Axes\n\n\n////////////////////// Plot Data \n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "href": "d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#and-now-some-scrollytelling",
    "href": "d3Chart2.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n\n\n```{ojs}\n\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 240, column 84)Unexpected token"
  },
  {
    "objectID": "d3Chart2.html#lets-try-again",
    "href": "d3Chart2.html#lets-try-again",
    "title": "Another visualisation",
    "section": "Let’s try again",
    "text": "Let’s try again\n\n```{ojs}\n\nimport ScrollyTeller from 'ScrollyTeller.js';\n\nstoryConfiguration = ({\n  appContainerId: 'app',\n  sectionList: [\n    intro,\n    wealthAndHealthConfig,\n    builtInTriggers,\n  ]\n});\n\nstoryInstance = new ScrollyTeller(storyConfiguration)\n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 281, column 8)Unexpected token"
  },
  {
    "objectID": "stories/dataStory0.html",
    "href": "stories/dataStory0.html",
    "title": "Data Story 0",
    "section": "",
    "text": "As demo’ed here : https://github.com/jimjam-slam/quarto-experiments/blob/main/scrollytelling/index.qmd.\n\n\nThis\nis\na\nlong\ncolumn\nof text\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nv\ne\nr\ny\nl\no\nn\ng\n.\n\n\n\nThis whole column has position:sticky; and top:100px on it!\n\nFIGURE\n\n\n\n\n\n\n\n\nA beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "stories/dataStory0.html#demo-sticky-overlay",
    "href": "stories/dataStory0.html#demo-sticky-overlay",
    "title": "Data Story 0",
    "section": "",
    "text": "A beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "stories/d3Chart2.html",
    "href": "stories/d3Chart2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "href": "stories/d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/d3Chart2.html#and-now-some-scrollytelling",
    "href": "stories/d3Chart2.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n\n```{ojs}\n\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 237, column 84)Unexpected token"
  },
  {
    "objectID": "stories/homepage.html",
    "href": "stories/homepage.html",
    "title": "homepage",
    "section": "",
    "text": "&lt;!DOCTYPE html&gt;\n\n\n\n  \n\n\n\n\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"overlap-group\"&gt;\n    &lt;div class=\"rectangle\"&gt;&lt;/div&gt;\n    &lt;div class=\"text-wrapper\"&gt;Copyright&lt;/div&gt;\n    &lt;div class=\"text-wrapper-2\"&gt;Terms of use&lt;/div&gt;\n    &lt;div class=\"text-wrapper-3\"&gt;Privacy policy&lt;/div&gt;\n    &lt;div class=\"rectangle-2\"&gt;&lt;/div&gt;\n    &lt;p class=\"ecoassets-received\"&gt;\n      &lt;span class=\"span\"&gt;EcoAssets received investment (&lt;/span&gt;\n      &lt;a href=\"https://doi.org/10.47486/XN005\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"span\"&gt;doi.org/10.47486/XN005&lt;/span&gt;&lt;/a&gt;\n      &lt;span class=\"span\"&gt;) from the Australian Research Data Commons (ARDC). The ARDC is funded by the Australian Research Data\n        National Collaborative Research Infrastructure Strategy (NCRIS).&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;div class=\"frame\"&gt;\n      &lt;div class=\"logos\"&gt;\n        &lt;img class=\"img\" src=\"img/rectangle-10.png\" /&gt;\n        &lt;img class=\"rectangle-3\" src=\"img/rectangle-11.png\" /&gt;\n        &lt;img class=\"rectangle-4\" src=\"img/rectangle-12.png\" /&gt;\n        &lt;img class=\"rectangle-5\" src=\"img/rectangle-13.png\" /&gt;\n        &lt;img class=\"rectangle-6\" src=\"img/rectangle-14.png\" /&gt;\n        &lt;img class=\"rectangle-7\" src=\"img/rectangle-15.png\" /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;p class=\"acknowledgement-of\"&gt;\n      &lt;span class=\"text-wrapper-4\"&gt;Acknowledgement of Traditional Owners and Country&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-5\"\n        &gt;&lt;br /&gt;The project partners acknowledge Australia’s Traditional Owners and pay respect to the past and\n        present Elders of the nation’s Aboriginal and Torres Strait Islander communities. We honour and\n        celebrate the spiritual, cultural and customary connections of Traditional Owners to the country and the\n        biodiversity that forms part of that country.&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;img class=\"line\" src=\"img/line-1.svg\" /&gt;\n  &lt;/div&gt;\n  &lt;div class=\"rectangle-8\"&gt;&lt;/div&gt;\n&lt;/footer&gt;\n&lt;div class=\"news\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;News&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"&gt;View latest updates &gt; &lt;/span&gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"data\"&gt;\n  &lt;div class=\"explore-data-explore-wrapper\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Explore Data&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;Explore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and\n        TERN.&lt;br /&gt;&lt;br /&gt;See data &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"welcome\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Welcome to EcoAssets&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;EcoAssets brings together environmental data collected from three national research infrastructures –\n        the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the\n        information can be streamlined into integrated data assets to support Australia&#39;s environmental\n        reporting needs.&lt;br /&gt;&lt;br /&gt;Learn more &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;header class=\"header\"&gt;\n  &lt;div class=\"overlap-2\"&gt;\n    &lt;div class=\"title-background\"&gt;\n      &lt;div class=\"div-wrapper\"&gt;&lt;div class=\"text-wrapper-9\"&gt;EcoAssets&lt;/div&gt;&lt;/div&gt;\n      &lt;div class=\"rectangle-9\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"nav-bar\"&gt;\n      &lt;div class=\"overlap-3\"&gt;\n        &lt;div class=\"text-wrapper-10\"&gt;About&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"overlap-4\"&gt;\n        &lt;div class=\"text-wrapper-11\"&gt;Data&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down-2\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"text-wrapper-12\"&gt;News&lt;/div&gt;\n      &lt;img class=\"fi-bs-search\" src=\"img/fi-bs-search.svg\" /&gt;\n      &lt;img class=\"fi-bs-home\" src=\"img/fi-bs-home.svg\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/header&gt;\n&lt;img class=\"main-image\" src=\"img/main-image.png\" /&gt;\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "stories/d3Chart.html",
    "href": "stories/d3Chart.html",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "stories/d3Chart.html#a-d3-chart",
    "href": "stories/d3Chart.html#a-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "stories/d3Chart.html#an-interactive-seal",
    "href": "stories/d3Chart.html#an-interactive-seal",
    "title": "A custom d3 visualisation",
    "section": "An interactive Seal",
    "text": "An interactive Seal\nThis was made with: https://robisateam.github.io/courses/web-course/5-javascript\n\n  \n\n\nFeed\nSwim\n\nseal_image = document.getElementById('seal');\nfeed_button = document.getElementById('feed-button')\nswim_button = document.getElementById('swim-button')\n\n// detect if someone clicks on the image -&gt; event listeners constantly check if someone performs a certain action\n// event listener takes 2 args: the type of event and a callback\n// callback: a function that explains what we want it to do when the event fires -&gt; in this case, execute a function called cricket\n//beetle_image.addEventListener(\"click\", cricket);\n\nfunction roar() {\n  alert(\"roooaaaaar\");\n};\n\n// create an inline function to execute a sequence of functions -&gt; only defined in the scope of this specific callback\nseal_image.addEventListener(\"click\", function() {\n  roar();\n  //scratch();\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfeed_button.addEventListener(\"click\", feed);\n\n\n\n\n\n\n\nfunction feed() {\n  seal_image.style.height = (seal_image.offsetHeight + 30.0) + 'px';\n};\nswim_button.addEventListener(\"dblclick\", function() {\n  seal_image.style.height = (seal_image.offsetHeight - 30.0) + 'px'\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = [10, 20, 30];\nconsole.log(data);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_object0 = ({name:\"cat\", weight: 10});\ncat_object = ({weight : 5, past_weight_values : 5, name : \"Princess Caroline\"});\n\ncat_list = [cat_object]; // initializing with the first field being cat_object\ncat_list.push({weight : 6 , past_weight_values : [5.9, 5.3, 6.1], name : \"Snowball\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_list.push({weight : 2})\n\n\n\n\n\n\n\nconsole.log(cat_list)"
  },
  {
    "objectID": "stories/exampleStory.html",
    "href": "stories/exampleStory.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/exampleStory.html#wealth-and-health-of-nations-on-plot",
    "href": "stories/exampleStory.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/exampleStory.html#and-now-some-scrollytelling",
    "href": "stories/exampleStory.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n// instance of CSSNames class\n// Can be used to override the default naming of id's and css classes. If left undefined, the default naming will be used.\n\nclass CSSNames {\n  /*scrollContainer= \"scroll\",\n  sectionContainer= 'section',\n  narrationList= 'narration_list',\n  narrationBlock= 'narration',\n  narrationContent= 'narration-content',\n  graphContainer= 'graph',\n  graphContainerDefault= 'graph_default',\n  graphTitleClass= 'graph_title',\n  graphCaptionClass= 'graph_caption',\n  linkContainer= 'link',*/\n  \n  constructor() {\n    this.scrollContainer= 'scroll',\n    this.sectionContainer= 'section',\n    this.narrationList= 'narration_list',\n    this.narrationBlock= 'narration',\n    this.narrationContent= 'narration-content',\n    this.graphContainer= 'graph',\n    this.graphContainerDefault= 'graph_default',\n    this.graphTitleClass= 'graph_title',\n    this.graphCaptionClass= 'graph_caption',\n    this.linkContainer= 'link'\n  }\n};\n\n\n\n\n\n\n\nscrollyteller = require('@ihmeuw/scrollyteller@1.0.2');\nlodash = import('https://unpkg.com/lodash-es@4.17.21/lodash.js?module');\n// intro = FileAttachment(\"exampleStory/00_intro/scrollyTellerConfig.js\");\n\n\n// A helper function\nupdateSvgImage = (graphId, state, previousSvgFileName) =&gt; {\n  const {\n    svgFileName,\n  } = state;\n  if (lodash.isNil(svgFileName)) {\n    const graph = d3.select(`#${graphId} .imageDiv`);\n    graph\n      .transition()\n      .duration(250)\n      .style('opacity', 0);\n  }\n  if (svgFileName !== previousSvgFileName) {\n    const html = svgFileName\n      ? `&lt;img src=\"dist/images/${svgFileName}.svg\" /&gt;`\n      : null;\n    const graph = d3.select(`#${graphId} .imageDiv`);\n    graph\n      .transition()\n      .duration(250)\n      .style('opacity', 0)\n      .on('end', () =&gt; {\n        graph\n          .html(html)\n          .transition()\n          .duration(250)\n          .style('opacity', svgFileName ? 1 : 0);\n      });\n  }\n};\n\n// local state object- constant \nsectionState = ({svgFileName: ''});\n\n/* CSSNames = ({\n  scrollContainer: 'scroll',\n  sectionContainer: 'section',\n  narrationList: 'narration_list',\n  narrationBlock: 'narration',\n  narrationContent: 'narration-content',\n  graphContainer: 'graph',\n  graphContainerDefault: 'graph_default',\n  graphTitleClass: 'graph_title',\n  graphCaptionClass: 'graph_caption',\n  linkContainer: 'link',\n}); */\n\nintro = ({\n  sectionIdentifier: 'introduction',\n\n  /** narration can be either of the following 3 options:\n   *  1) a string representing an absolute file path to a file of the following types:\n   *      'csv', 'tsv', 'json', 'html', 'txt', 'xml', which will be parsed by d3.promise\n   *  2) array of narration objects,\n   *  3) a promise to return an array of narration objects in the appropriate form\n   * See README for the specification of the narration objects */\n  narration: FileAttachment(\"narration.csv\").csv(),\n\n  data: [],\n  \n  convertTriggerToObject: true,\n  \n  // css names - not required but prevents bugs\n   cssNames : new CSSNames(),\n  /**\n   * Optional method to reshape the data passed into ScrollyTeller, or resolved by the data promise\n   * @param {object} results - data passed into ScrollyTeller or the result of resolving the data promise (see below).\n   * @returns {object|array} -  an object or array of data of user-defined shape\n   */\n  reshapeDataFunction: function processData(results) {\n    return {};\n  },\n  \n   /**\n   * Called AFTER data is fetched, and reshapeDataFunction is called.  This method should\n   * build the graph and return an instance of that graph, which will passed as arguments\n   * to the onScrollFunction and onActivateNarration functions.\n   *\n   * This function is called as follows:\n   * buildGraphFunction(graphId, sectionConfig)\n   * @param {string} graphId - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} sectionConfig - the configuration object passed to ScrollyTeller\n   * @param {object} [sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {object} - chart instance\n   */\n  buildGraphFunction: function buildGraph(graphId, sectionConfig) {\n    /** REMEMBER TO RETURN THE GRAPH! (could also return as an object with multiple graphs, etc)\n     * The graph object is assigned to sectionConfig.graph, which is returned to all scrollyteller\n     * functions such as buildGraphFunction(), onActivateNarrationFunction(), onScrollFunction()  */\n    d3.select(`#${graphId}`)\n      .append('div')\n      .classed('imageDiv', true)\n    updateSvgImage(graphId, { svgFileName: 'slide1' }, sectionState.svgFileName);\n    sectionState.svgFileName = 'slide1';\n    return undefined;\n  },\n\n  /**\n   * Called upon scrolling of the section. See argument list below, this function is called as:\n   * onScrollFunction({ index, progress, element, trigger, graphId, sectionConfig })\n   * @param {object} [params] - object containing parameters\n   * @param {number} [params.index] - index of the active narration object\n   * @param {number} [params.progress] - 0-1 (sort of) value indicating progress through the active narration block\n   * @param {HTMLElement} [params.element] - the narration block DOM element that is currently active\n   * @param {string} [params.trigger] - the trigger attribute for narration block that is currently active\n   * @param {string} [params.graphContainerId] - id of the graph container in this section. const graphContainer = d3.select(`#${graphContainerId}`);\n   * @param {string} [params.graphId] - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} [params.sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [params.sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [params.sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [params.sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [params.sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [params.sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {void}\n   */\n  onScrollFunction: function onScroll() {\n  },\n  \n  /**\n   * Called when a narration block is activated.\n   * See argument list below, this function is called as:\n   * onActivateNarration({ index, progress, element, trigger, graphId, sectionConfig })\n   * @param {object} [params] - object containing parameters\n   * @param {number} [params.index] - index of the active narration object\n   * @param {number} [params.progress] - 0-1 (sort of) value indicating progress through the active narration block\n   * @param {HTMLElement} [params.element] - the narration block DOM element that is currently active\n   * @param {string} [params.trigger] - the trigger attribute for narration block that is currently active\n   * @param {string} [params.direction] - the direction the event happened in (up or down)\n   * @param {string} [params.graphContainerId] - id of the graph container in this section. const graphContainer = d3.select(`#${graphContainerId}`);\n   * @param {string} [params.graphId] - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} [params.sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [params.sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [params.sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [params.sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [params.sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [params.sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {void}\n   */\n  onActivateNarrationFunction: function onActivateNarration({\n    graphId,\n    state,\n    state: {\n      svgFileName,\n    },\n  }) {\n    /** DISPLAY/FLIP BETWEEN IMAGES */\n    updateSvgImage(graphId, state, sectionState.svgFileName);\n    sectionState.svgFileName = svgFileName;\n  },\n\n});\n\nintro.cssNames.constructor.name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstoryConfiguration = ({\n  /* The id of the &lt;div&gt; that will contain all of the page content */\n  appContainerId: \"app\",\n  /*build an array of story sections, each section object should be a valid ScrollyTeller section configuration */\n  sectionList: [intro],\n});\n\nstoryConfiguration.sectionList[0].cssNames.constructor.name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsi = new scrollyteller.default(storyConfiguration);\n\n/* parse data and build all HMTL */\nsi.render();"
  },
  {
    "objectID": "stories/ECharts.html",
    "href": "stories/ECharts.html",
    "title": "Sample GeoMap with ECharts",
    "section": "",
    "text": "Sample GeoMap with ECharts\n–&gt; install python & jupyter –&gt; add to header: jupyter: python3\nFrom this site: https://medium.com/@emmanueldavidson/creating-beautiful-analytics-documents-with-quarto-and-observable-js-a4a746f8793a\nIn this example, we’re creating a GeoMap visualization using ECharts and embedding it within an Observable.js cell in a Quarto document. Let’s break down how this integration works:\nQuarto Document Structure: We start with the Quarto document structure. Quarto allows you to use a combination of Markdown and code chunks to structure your content. Observable.js Cell: Within the document, we use the {ojs} code chunk to define an Observable.js cell. This cell contains JavaScript code for creating our interactive GeoMap. JavaScript Code: Inside the Observable.js cell, we write JavaScript code to customize our GeoMap. This includes defining functions, processing data, and configuring the map using ECharts. Dynamic Visualization: Observable.js allows us to create dynamic and interactive visualizations. The code interacts with the DOM to render the GeoMap within an HTML div element. External Libraries: We can import external libraries like ECharts using JavaScript’s require function. This allows us to leverage powerful visualization libraries within our document. Data Import: Observable.js can also fetch data from external sources, such as a GeoJSON file, and use it to render the map. By combining Quarto’s document structuring capabilities with Observable.js’s real-time interactivity, you can create analytics documents that not only present your insights but also allow readers to explore data and visualizations dynamically.\nThis Quarto document demonstrates how to create a simple geospatial map using ECharts and display it in an Observable.js cell.\n\n\nCode\nfunction customizeCity(cityData, emphasisColor, itemStyleColor, tooltipFormatter) {\n  return {\n    name: cityData.name,\n    value: cityData.value,\n    itemStyle: {\n      color: itemStyleColor, // Default color is blue\n      borderWidth: 2,\n      borderColor: 'black'\n    },\n    tooltip: {\n        formatter: tooltipFormatter, // Default tooltip format\n    }\n  };\n}\n\nrawData = [\n    {name: 'London', value: [-0.1275, 51.507222]},\n    {name: 'Birmingham', value: [-1.92, 52.48]},\n    {name: 'Manchester', value: [-2.24, 53.48]},\n    {name: 'Leeds', value: [-1.55, 53.79]},\n    {name: 'Glasgow', value: [-4.25, 55.86]},\n    {name: 'Newcastle', value: [-1.6, 54.98]},\n    {name: 'Sheffield', value: [-1.47, 53.38]},\n    {name: 'Liverpool', value: [-2.97, 53.4]},\n    {name: 'Bristol', value: [-2.58, 51.45]},\n    {name: 'Belfast', value: [-5.93, 54.6]},\n    { name: 'Cairo', value: [31.2357, 30.0444] },\n    { name: 'Lagos', value: [3.3792, 6.5244] },\n    { name: 'Nairobi', value: [36.8219, -1.2921] },\n    { name: 'Johannesburg', value: [28.0473, -26.2041] },\n    { name: 'Cape Town', value: [18.4241, -33.9249] },\n    { name: 'Casablanca', value: [-7.6114, 33.5731] },\n    { name: 'Accra', value: [-0.186964, 5.603717] },\n    { name: 'Nairobi', value: [36.8219, -1.2921] },\n    { name: 'Khartoum', value: [32.5549, 15.5007] },\n    { name: 'Abuja', value: [7.49508, 9.05785] }\n                \n]\n\ncities = rawData.map(city =&gt; customizeCity(city, 'green', 'red', `${city.name} - Population: 1000`));\n\n\necharts = require(\"https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.js\")\nrootDiv = html`&lt;div id=\"main\" style=\"width: 800px;height: 800px;\"&gt;&lt;/div&gt;`\nmyChart = echarts.init(rootDiv);\nconsole.log(echarts.api)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n{   \n    const data =  await FileAttachment(\"assets/the-worlds-oceans.geojson\").json();\n    echarts.registerMap('WORLD', data);\n    const option = {\n        tooltip: {},\n        title: {\n            text: 'UK Population Density',\n            subtext: 'Data from 2011 census',\n            left: 'center'\n        },\n        backgroundColor: '#fff',\n        darkMode: true,\n        geo: {\n            map: 'WORLD',\n            roam: true,\n            zoom: 1.2,\n            tooltip: {\n                show: true,\n            },\n            boundingCoords: [\n                [-180, 90],\n                [180, -90]\n            ],\n            emphasis: {\n                label: {\n                    show: true,\n                    color: \"#342FB4\"\n                },\n                itemStyle: {\n                    borderColor: \"#2FB42F\",\n                    borderWidth: 1,\n                },\n                // focus: 'self'\n\n                \n            },\n            itemStyle: {\n                borderColor: \"#000\",\n                color: \"#000\",\n                \n            },\n            \n        },\n\n        series: [\n            {\n                type: 'custom',\n                coordinateSystem: 'geo',\n                data: cities,\n                renderItem: function (params, api) {\n                    console.log(params)\n                    console.log(api)\n\n                    const coord = api.coord([\n                        api.value(0, params.dataIndex),\n                        api.value(1, params.dataIndex)\n                    ]);\n                    return {\n                        type: 'path',\n                        x: coord[0],\n                        y: coord[1],\n                        shape: {\n                            d: 'M16 0c-5.523 0-10 4.477-10 10 0 10 10 22 10 22s10-12 10-22c0-5.523-4.477-10-10-10zM16 16c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686 6 6-2.686 6-6 6z',\n                            x: -10,\n                            y: -35,\n                            width: 20,\n                            height: 40\n                        },\n\n                        emphasis:{\n                            itemStyle: {\n                                borderWidth: 3,\n                                borderColor: 'grey',\n                                shadowBlur: 10,\n                            \n                            },\n                            style: {\n                                shadowBlur: 10,\n                                shadowColor: \"red\"\n                            }\n                        } ,\n                        style: api.style({\n                            fill: api.visual('color'),\n                            stroke: api.visual('borderColor'),\n                            lineWidth: 1,\n                            shadowBlur: 2,\n                            shadowColor: '#000'\n                        }),\n                        \n                    };\n                },\n                \n\n                \n            },\n            \n        ]\n    };\n   \n    myChart.setOption(option);\n}"
  },
  {
    "objectID": "stories/exampleStory2.html",
    "href": "stories/exampleStory2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "```{ojs}\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 106, column 84)Unexpected token"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html",
    "href": "stories/ecoAssetsDataStory.html",
    "title": "EcoAssets",
    "section": "",
    "text": "What is EcoAssets\n\n\n\nBubble graph of organisations\n\nPLOT 1: Bubble graph of data contribution by ALA, IMOS, TERN"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-1",
    "href": "stories/ecoAssetsDataStory.html#section-1",
    "title": "EcoAssets",
    "section": "Section 1",
    "text": "Section 1\n\n\nWhat is EcoAssets?\n\n\n\nBubble graph of organisations\n\nPLOT 1: Bubble graph of data contribution by ALA, IMOS, TERN ::: {style=“height: 50vh;”}\n\nimport { chart4 } from \"@clarapt-ws/ecoassets-dataviz-4-zoomable-circle-plot\"\nchart4"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-2",
    "href": "stories/ecoAssetsDataStory.html#section-2",
    "title": "EcoAssets",
    "section": "Section 2",
    "text": "Section 2\n\n\nThe ALA, IMOS and TERN have been collecting data since … And every year, they collect and publish more and more data…\n\n\n\n\nPLOT 2: Line graph of counts vs years (biodiversity data)\n\nimport { linegraph } from \"@clarapt-ws/experiments-in-scrollytelling-part-2\"\nlinegraph"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-3",
    "href": "stories/ecoAssetsDataStory.html#section-3",
    "title": "EcoAssets",
    "section": "Section 3",
    "text": "Section 3\nAnd they have data about …"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-1.5",
    "href": "stories/ecoAssetsDataStory.html#section-1.5",
    "title": "EcoAssets",
    "section": "Section 1.5",
    "text": "Section 1.5\n\n\n\nLet’s break up the page a bit"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#cam-we-start-a-section-here",
    "href": "stories/ecoAssetsDataStory.html#cam-we-start-a-section-here",
    "title": "EcoAssets Data Story",
    "section": "Cam we start a section here?",
    "text": "Cam we start a section here?\n\nAuto-column\n\n\nAuto-column"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-4",
    "href": "stories/ecoAssetsDataStory.html#section-4",
    "title": "EcoAssets",
    "section": "Section 4",
    "text": "Section 4\n\n\nBiodiversity data\n\n\nSum of Occurrence Counts by Australian States and Territories as proportion of total count for 2022\nFrom EcoAssets Biodiversity aggregate data set\n\nimport { viewof type } from \"@clarapt-ws/ecoassets-dataviz-6-shape-tweening\"\nshape_chart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { chart as shape_chart } from \"@clarapt-ws/ecoassets-dataviz-6-shape-tweening\"\nshape_chart"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-5",
    "href": "stories/ecoAssetsDataStory.html#section-5",
    "title": "EcoAssets",
    "section": "Section 5",
    "text": "Section 5\n\n\nAuto-column\n\n\n\nMonitoring Data\n\n\nCounts of monitoring events for EcoAssets data providers, log scaled\n\nmyData = [{ id: \"flare.ALA.ALA\", value: scale(120373)}, {id: \"flare.IMOS.IMOS\", value: scale(737672)}, {id: \"flare.TERN.TERN\", value: scale(8971)}]\n\nscale = d3.scaleLog().domain([8971, 737672]).range([0, 100]).nice()\n\nchart3 = {\n  // Specify the dimensions of the chart.\n  const width = 928;\n  const height = width;\n  const margin = 1; // to avoid clipping the root circle stroke\n  const name = d =&gt; d.id.split(\".\").pop(); // \"Strings\" of \"flare.util.Strings\"\n  const group = d =&gt; d.id.split(\".\")[1]; // \"util\" of \"flare.util.Strings\"\n  const names = d =&gt; name(d).split(/(?=[A-Z][a-z])|\\s+/g); // [\"Legend\", \"Item\"] of \"flare.vis.legend.LegendItems\"\n\n  // Specify the number format for values.\n  const format = d3.format(\",d\");\n\n  // Definiendo tus propios colores\nconst color = d3.scaleOrdinal()\n  .range([\"#FF7000\", \"#00ABFF\", \"#0AC42E\"]);\n\n  // Create the pack layout.\n  const pack = d3.pack()\n      .size([width - margin * 2, height - margin * 2])\n      .padding(3);\n\n  // Compute the hierarchy from the (flat) data; expose the values\n  // for each node; lastly apply the pack layout.\n  const root = pack(d3.hierarchy({children: myData})\n      .sum(d =&gt; d.value));\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [-margin, -margin, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; font: 20px sans-serif;\")\n      .attr(\"text-anchor\", \"middle\");\n\n  // Place each (leaf) node according to the layout’s x and y values.\n  const node = svg.append(\"g\")\n    .selectAll()\n    .data(root.leaves())\n    .join(\"g\")\n      .attr(\"transform\", d =&gt; `translate(${d.x},${d.y})`);\n\n  // Add a title.\n  node.append(\"title\")\n      .text(d =&gt; `${d.data.id}\\n${format(d.value)}`);\n\n  // Add a filled circle.\n  node.append(\"circle\")\n      .attr(\"fill-opacity\", 0.8)\n      .attr(\"fill\", d =&gt; color(group(d.data)))\n      .attr(\"r\", d =&gt; d.r);\n\n  // Add a label.\n  const text = node.append(\"text\")\n      .attr(\"clip-path\", d =&gt; `circle(${d.r})`);\n\n  // Add a tspan for each CamelCase-separated word.\n  text.selectAll()\n    .data(d =&gt; names(d.data))\n    .join(\"tspan\")\n      .attr(\"x\", 0)\n      .attr(\"y\", (d, i, nodes) =&gt; `${i - nodes.length / 2 + 0.35}em`)\n      .text(d =&gt; d);\n\n  // Add a tspan for the node’s value.\n  text.append(\"tspan\")\n    .attr(\"x\", 0)\n    .attr(\"y\", d =&gt; `${names(d.data).length / 2 + 0.35}em`)\n    .attr(\"fill-opacity\", 0.7)\n    .text(d =&gt; `${format(d.value)}`);\n\n  return Object.assign(svg.node(), {scales: {color}});\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuto-column"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-6",
    "href": "stories/ecoAssetsDataStory.html#section-6",
    "title": "EcoAssets",
    "section": "Section 6",
    "text": "Section 6\nThe aggregated datasets have been used for environmental reporting\n[Plot from Shandiya’s presentation]"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-7",
    "href": "stories/ecoAssetsDataStory.html#section-7",
    "title": "EcoAssets",
    "section": "Section 7",
    "text": "Section 7\nAnd also for more interesting things…"
  },
  {
    "objectID": "about.html#about-the-project",
    "href": "about.html#about-the-project",
    "title": "About EcoAssets",
    "section": "",
    "text": "EcoAssets is improving access to integrated environmental data in forms that can support national, and state and territory environmental assessment and reporting activities. The project was established to support the authors of the 2021 Federal State of the Environment (SoE) report which reviews how different pressures are changing Australia’s land and marine environments and how these changes will impact the economy and society.\nAustralian environmental research infrastructures and their data partners collect large amounts of data each year on all aspects of the environment. In the past these data have not been integrated across infrastructures, or provided at a scale and in a format suitable for environmental reporting at national, or state and territory levels.\nThrough EcoAssets, three of Australia’s national research infrastructures - the ALA, IMOS and TERN - are working together to deliver open integrated data to support environmental assessment and reporting needs.\nThe key resulting data assets are: Integrated species distribution data asset Integrated survey and monitoring activity data asset EcoAssets is achieving these outcomes by identifying opportunities to increase alignment between data from all partners. In particular, we are simplifying spatiotemporal analyses and addressing differences in terminology and vocabularies."
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#sum-of-occurrence-counts-by-australian-states-and-territories-as-proportion-of-total-count-for-2022",
    "href": "stories/ecoAssetsDataStory.html#sum-of-occurrence-counts-by-australian-states-and-territories-as-proportion-of-total-count-for-2022",
    "title": "EcoAssets",
    "section": "Sum of Occurrence Counts by Australian States and Territories as proportion of total count for 2022",
    "text": "Sum of Occurrence Counts by Australian States and Territories as proportion of total count for 2022\nFrom EcoAssets Biodiversity aggregate data set\n\nimport { viewof type } from \"@clarapt-ws/ecoassets-dataviz-6-shape-tweening\"\nshape_chart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { chart as shape_chart } from \"@clarapt-ws/ecoassets-dataviz-6-shape-tweening\"\nshape_chart"
  },
  {
    "objectID": "ClaraProjectSummary.html",
    "href": "ClaraProjectSummary.html",
    "title": "A summary of EcoAssets data visualization and scrollytelling scoping project",
    "section": "",
    "text": "Data Visualisation\n\nData Visualizations created during the project\nDuring the project, I created a number of custom data visualizations using subsets of the EcoAssets data. These were created in Observable, a JavaScript platform that allows you to create data viz’s by embedding JS cells in R markdown documents. I used the Observable notebooks, available via the browser, and then would add this content to my quarto website. The collection of data viz notebooks that I made can be found here. They are all public and can be directly edited, or forked and then edited (you need an Observable account to do this).\nWhen working in Observable, you typically use JavaScript to create visualizations, however, you can also add code in markdown or html cells. In JavaScript, the two main libraries I used were Plot (the Observable Javascript library) and d3.js. Plot is a great library to get started with Observable and play around with the data because it is very easy to create visualizations quickly. D3.js stands for data driven documents and is a free open-source JS library for visualizing data, see gallery and Observable d3 gallery. It is used to animate data viz’s, and is a low-level approach- every element on the page has to be explicitly added to the visualization. D3.js is much more effective for creating more custom visualizations than Plot, but has a much steeper learning curve, especially if you have never coded in JavaScript before. I used Observable’s tutorials to learn both Plot and d3, and I definitely recommend these.\nIt’s also worth mentioning that you can embed Echarts into quarto websites using ObservableJS code blocks, this is not something I experimented with but see an example here.\n\n\n\nScrollytelling\nScrollytelling is a way of telling a long-form story in a very engaging way, by combining visual content, text and even audio that changes as the user scrolls down the page. It’s typically used in long-form journalism, you may have seen example in the ABC or similar. The overarching idea for EcoAssets was to create a library of data stories that explain different themes within the EcoAssets datasets. Scrollytelling is useful in cases where there’s a lot of data, or where there are many possible uses of the data. This is true of the EcoAssets datasets, which are very large and could be subsetted in many ways to answer different questions about biodiversity and monitoring. It’s also helpful in guiding users who may not have a clear idea of what the data contains, or know how to use it. Scrollytelling provides a way to guide users through these datasets by literally telling them a story about the data and using visuals along to way to explain or clarify the points you’re making.\n\nInspiration for scrollytelling and other resources:\n\nFrench ministry of agriculture scrollytelling gallery\nABC custom javascript libraries\nAn argument structure for data stories\nTelling stories with data online textbook\n\n\n\nJavaScript libraries for scrollytelling\nScrollama.js is a a modern & lightweight JS library for scrollytelling using IntersectionObserver in favor of scroll events, examples here. It works well embedded into Quarto websites with OJS code blocks.\nScrollyteller.js ( see an introductory article and an example story on child mortality ), it’s a JS library that builds the HTML for a scrolling data story from csv files, and provides a flexible framework for triggering chart actions when text “narration” scrolls into view. After much experimentation, it seems this cannot yet be embedded into Observable notebooks, let alone Quarto websites. May work in HTML/JavaScript directly.\nSome other libraries I discovered that looked promising but I did not get a chance to experiment with are:\n\nGSAP.js, a popular animation library\nPlotteus is a new JS library that users have developed to work with Observable. It includes basic functionality for changing chart types etc.\nFlourish as a no-code alternative to Javascript. Note that users must pay to access scrollytelling features in Flourish.\nIt is also possible to add scrolltriggers to animated charts using d3\n\nThese have been documented on Observable in my collection of story attempts as well as other notebooks that have implemented some of the libraries mentioned.\n\n\n\nR code for Data viz’s created\n\nExploring the Biodiversity datasets\n\n# Exploring Aggregate datasets of Biodiversity data 2023\n\naggregateOccurrences &lt;- read.csv('AggregatedData_AustralianSpeciesOccurrences_1.1.2023-06-13.csv')\nprotectTer &lt;- read.csv('SummaryData-ProtectionStatusAustralianTerrestrialSpeciesOccurrences-1.1.2023-06-13.csv')\nprotectMar &lt;- read.csv('SummaryData-ProtectionStatusAustralianMarineSpeciesOccurrences-1.1.2023-06-13.csv')\nthreatTer &lt;- read.csv('SummaryData-ThreatenedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv')\nthreatMar &lt;- read.csv('SummaryData-ThreatenedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv')\nintroTer &lt;- read.csv('SummaryData-IntroducedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv')\nintroMar &lt;- read.csv('SummaryData-IntroducedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv')\n\nepbcStatus &lt;- unique(aggregateOccurrences$epbcStatus)\ngriisStatus &lt;- unique(aggregateOccurrences$griisStatus)\n\n#find first occurence with imcra region\naggregateOccurrences[which(aggregateOccurrences$imcraRegion!=\"\")[1],]\n\n#search for all koala Occurrences\nkoalaOccurrences &lt;- aggregateOccurrences[grep(\"Phascolarctos cinereus\", aggregateOccurrences$speciesName), ]\n\nnumSpecies &lt;- unique(aggregateOccurrences$speciesID)\n\n# Order species by count\naggregateSorted &lt;- aggregateOccurrences[order(aggregateOccurrences$occurrenceCount, decreasing = TRUE), ]\n\ntopCountSpecies &lt;- aggregateSorted[1:250, ]\n\ncountUnique &lt;- unique(topCountSpecies$speciesName)\n\ntopCountSpecies$vernacularName\ntopCountSpecies$class\n\nfor (i in 1:length(topCountSpecies$speciesName)) {\n  name &lt;- topCountSpecies$speciesName[i]\n  output &lt;- search_taxa(name)\n  topCountSpecies$vernacularName[i] &lt;- output$vernacular_name\n  topCountSpecies$class[i] &lt;- output$class\n}\n\n# filter any empty rows... this doesn't quite work \ntopCountSpeciesF &lt;- topCountSpecies[!(is.na(topCountSpecies$ibraRegion) \n                                         | topCountSpecies$ibraRegion == \"\"), ]\n\n\n##### Galah : exploring package functionality\n\ninstall.packages(\"galah\")\nlibrary(galah)\n\n# choosing an atlas\nshow_all(atlases)\ngalah_config(atlas = \"ALA\")\n\natlas_counts()\n# Use galah_ functions after the call...\ngalah_call() |&gt;\n  galah_identify(\"https://biodiversity.org.au/afd/taxa/b6f829dd-0aef-4422-a3f6-77ff691aa9af\") |&gt;\n  atlas_species()\n\n# ...or dplyr functions \ngalah_call() |&gt;\n  filter(year &gt;= 2020) |&gt; \n  group_by(year) |&gt;\n  count() |&gt;\n  collect()\n\n# to search by taxonomic group\nsearch_taxa(\"reptilia\")\nsearch_taxa(\"Wallabia bicolor\")\n\ngalah_call() |&gt;\n  galah_filter(year &gt;= 2020) |&gt; \n  galah_identify(\"reptilia\") |&gt; \n  atlas_counts()\n\nranks &lt;- show_all_ranks()\nsearchOuput &lt;- search_taxa(\"Wallabia bicolor\")\nclass &lt;- galah_call() |&gt; galah_group_by(class) |&gt; atlas_counts()\n\n\n##### explore CAPAD status\n\ntotalCount &lt;- nrow(aggregateOccurrences)\nprotected &lt;- unique(aggregateOccurrences$capadStatus)\n\nindigenous &lt;- aggregateOccurrences[grep(\"IPA\", aggregateOccurrences$capadStatus), ]\nprotected &lt;- aggregateOccurrences[grep(\"PA\", aggregateOccurrences$capadStatus), ]\nnp &lt;- aggregateOccurrences[grep(\"not protected\", aggregateOccurrences$capadStatus), ]\n\nipaPerCent &lt;- (nrow(indigenous)/totalCount)*100\nprotectedPerCent &lt;- (nrow(protected)/totalCount)*100\nnpPerCent &lt;- (nrow(np)/totalCount)*100\n\nnrow(indigenous[grep(\"Native\", indigenous$griisStatus), ])/nrow(indigenous)\nnrow(protected[grep(\"Native\", protected$griisStatus), ])/nrow(protected)\nnrow(np[grep(\"Native\", np$griisStatus), ])/nrow(np)\n\nlibrary(\"dplyr\")\nyear &lt;- (aggregateOccurrences %&gt;% group_by(year) %&gt;% summarize(count=n()))\n# aggregate(data.frame(count = v), list(value = v), length)\n\n\n##### explore GRIIS status\n\n# to create a stream graph: table with date/griis status/count, with the count aggregated for each year\n\ngriisAggregate &lt;- (aggregateOccurrences %&gt;% select(year, griisStatus, occurrenceCount))\ngriisAggregateSum &lt;- (griisAggregate %&gt;% group_by(year, griisStatus) %&gt;% summarize(sum(occurrenceCount)))\n\ncolnames(griisAggregateSum)[3] &lt;- \"occurrenceCount\"\n\nwrite.csv(griisAggregateSum, path)\n\nlibrary(jsonlite)\n\ncat(toJSON(griisAggregateSum), file = \"griisAggregateData.json\")\n\n\n##### explore animal class \n\nlibrary(galah)\nlibrary(jsonlite)\naggregateOccurrences &lt;- read.csv('AggregatedData_AustralianSpeciesOccurrences_1.1.2023-06-13.csv')\nclass &lt;- \"class\"\naggregateClass &lt;- cbind(aggregateOccurrences, class)\n\n#add class column to aggregate data\nfor (i in 1:nrow(aggregateClass)){\n  output &lt;- search_taxa(aggregateClass$speciesName[i])\n  aggregateClass$class[i] &lt;- output$class\n}\n# save this new csv\n\n# group by year and sum counts\naggregateClassGrouped &lt;- (aggregateClass %&gt;% select(year, class, occurrenceCount) %&gt;% group_by(year, class))\n\n# convert to json? \n#find first occurence with imcra region\n\naggregateClass[which(aggregateClass$class==\"class\")[1],]\n\n\n##### Subset the aggregate data to add in to Observable\n\nsubsetAggregate &lt;- aggregateOccurrences[grep(\"2014\", aggregateOccurrences$year), ]\nwrite.csv(subsetAggregate, \"C:\\\\Users\\\\PEE040\\\\OneDrive - CSIRO\\\\Documents\\\\EcoAssets\\\\BiodiversityData_2023\\\\Hobern_Donald_18_Dec_2023\\\\data\\\\aggregateOccurrences2014.csv\", row.names=FALSE)\n\n## Year counts of biodiversity data\n\nlibrary(dplyr)\nyearCounts &lt;- (aggregateOccurrences %&gt;% group_by(year) %&gt;% summarise(count=n()))\n\nlibrary(ggplot2)\nggplot(data=yearCounts, aes(x=year, y=count, group=1)) + geom_line() + geom_point()\n\nwrite.csv(yearCounts, \"C:\\\\Users\\\\PEE040\\\\OneDrive - CSIRO\\\\Documents\\\\EcoAssets\\\\biodiversityYearCounts.csv\", row.names = FALSE)\n\n\n## Sample data frame\n\nsampleSet &lt;- aggregateOccurrences[sample(nrow(aggregateOccurrences), 5), ]\nsaveRDS(sampleSet, file=\"biodiversity_sample.rds\")\n\n\n\nCreating a streamgraph for taxa - aggregate biodiversity dataset\n\n# Creating a Streamgraph for Taxa from aggregate biodiversity dataset\n\n# A note from Shandiya: Here's the list of taxonomic classifications for (I think) all the species in the aggregated datasets.\n## Use arrow to open parquet files: https://arrow.apache.org/docs/r/index.html.\n\n### Read in taxa\n# install.packages(\"arrow\")\ntaxa &lt;- arrow::read_parquet(\"rel_distinct_taxa.parquet\")\n\n### Read in aggregate dataset\naggregateOccurences &lt;- read.csv('AggregatedData_AustralianSpeciesOccurrences_1.1.2023-06-13.csv')\n\n### Join the datasets, adding taxa column to aggregate dataset\n\n# to create a stream graph: table with date/griis status/count, with the count aggregated for each year\n\nlibrary(dplyr)\naggregate &lt;- (aggregateOccurences %&gt;% select(year, speciesID, occurrenceCount))\naggregateSum &lt;- (aggregate %&gt;% group_by(year, speciesID) %&gt;% summarize(sum(occurrenceCount)))\n\ncolnames(aggregateSum)[3] &lt;- \"occurrenceCount\"\n\ntaxaOccurence &lt;- left_join(aggregateSum, taxa, by=\"speciesID\") #retain everything from aggregateSum\n\ntable(taxaOccurence$kingdom, useNA='always')\n\nlength(which(taxaOccurence$kingdom == \"Animalia\"))\n\nkingdomOccurence &lt;- (taxaOccurence %&gt;% \n                       select(year, kingdom, occurrenceCount) %&gt;% \n                       group_by(year, kingdom) %&gt;% \n                       summarize(sum(occurrenceCount)))\ncolnames(kingdomOccurence)[3] &lt;- \"occurrenceCount\"\n\nanimaliaOccurence &lt;- (taxaOccurence %&gt;% \n                        filter(kingdom == \"Animalia\") %&gt;%\n                        select(year, phylum, occurrenceCount) %&gt;% \n                        group_by(year, phylum) %&gt;% \n                        summarize(sum(occurrenceCount)))\ncolnames(animaliaOccurence)[3] &lt;- \"occurrenceCount\"\n\nclassOccurrence &lt;- (taxaOccurence %&gt;% \n                        filter(kingdom == \"Animalia\") %&gt;%\n                        select(year, class, occurrenceCount) %&gt;% \n                        group_by(year, class) %&gt;% \n                        summarize(sum(occurrenceCount)))\ncolnames(classOccurrence)[3] &lt;- \"occurrenceCount\"\n\norderOccurrence &lt;- (taxaOccurence %&gt;% \n                      filter(kingdom == \"Animalia\") %&gt;%\n                      select(year, order, occurrenceCount) %&gt;% \n                      group_by(year, order) %&gt;% \n                      summarize(sum(occurrenceCount)))\ncolnames(orderOccurrence)[3] &lt;- \"occurrenceCount\"\n\n\n# Fill in NA values\nkingdomOccurence[is.na(kingdomOccurence)] &lt;- \"No kingdom\"\nanimaliaOccurence[is.na(animaliaOccurence)] &lt;- \"No phylum\"\nclassOccurrence[is.na(classOccurrence)] &lt;- \"No class\"\norderOccurrence[is.na(orderOccurrence)] &lt;- \"No order\"\n\n### Create JSON with {year:, class:, occurenceCount:, } array \n\nlibrary(jsonlite)\n\ncat(toJSON(kingdomOccurence), file = \"kingdomOccurences.json\")\ncat(toJSON(animaliaOccurence), file=\"animaliaOccurences.json\")\ncat(toJSON(classOccurrence), file=\"classOccurences.json\")\ncat(toJSON(orderOccurrence), file=\"orderOccurrences.json\")\n\n\n\nCreate species and regions double circle plot\n\n##### Subset of regions and species for circle graph\n\naggregateOccurrences &lt;- read.csv('AggregatedData_AustralianSpeciesOccurrences_1.1.2023-06-13.csv')\naggregateSorted &lt;- aggregateOccurrences[order(aggregateOccurrences$occurrenceCount, decreasing = TRUE), ]\nvernacularName &lt;- \"vernacularName\"\nclass &lt;- \"class\"\nnumSpecies &lt;- 150\ntopSpecies &lt;- cbind(aggregateSorted[1:numSpecies, ], vernacularName, class)\n\n# then need to cross-check species and regions in topSpecies with agreggated occurrences \nspeciesList &lt;- unique(topSpecies$speciesName)\nibraList &lt;- unique(topSpecies$ibraRegion)\nimcraList &lt;- unique(topSpecies$imcraRegion)\n\n# create another dataframe with the missing data\n# from numSpecies + 1, loop through rows of table and if the the species is in the speciesList, add it to the data\n# Only keep rows where the ibra or imcra region is already in the created lists \nlibrary(dplyr)\nmissingData &lt;- aggregateSorted |&gt; filter(speciesName %in% speciesList)\nmissingDataRegions &lt;- missingData |&gt; filter(ibraRegion %in% ibraList) |&gt; filter(imcraRegion %in% imcraList)\n\ntopSpecies &lt;- missingDataRegions\n\n# Add vernacular name and class to topSpecies\nlibrary(galah)\nfor (i in 1:numSpecies) {\n  name &lt;- topSpecies$speciesName[i]\n  output &lt;- search_taxa(name)\n  # only add the vernacular name if not null\n  if (!is.null(output$vernacular_name)) {\n    topSpecies$vernacularName[i] &lt;- output$vernacular_name\n    topSpecies$class[i] &lt;- output$class\n  }\n}\n# Filter out species that don't have a vernacular name provided\ntopSpecies &lt;- topSpecies[topSpecies$vernacularName != \"vernacularName\", ]\n\nibraList &lt;- unique(topSpecies$ibraRegion)\nimcraList &lt;- unique(topSpecies$imcraRegion)\n\n# Convert to JSON\n# install.packages(\"jsonlite\")\nlibrary(jsonlite)\nlibrary(dplyr)\n\nspeciesRegion &lt;- mutate(topSpecies, region = paste(imcraRegion, ibraRegion)) \nspeciesRegion &lt;- (speciesRegion %&gt;% select(region, vernacularName, class))\ncolnames(speciesRegion)[2] &lt;- \"species\"\nspeciesRegion &lt;- speciesRegion |&gt; distinct(.keep_all = TRUE) #remove duplicate rows across entire data frame --&gt; years creates duplicates\nspeciesRegion &lt;- speciesRegion[order(speciesRegion$region, decreasing = FALSE), ] # make it in alphabetical order by regions\n\n# an attempt to create the JSON object with jsonlite functions - doesn't work \nlist &lt;- toJSON(speciesRegion) # creates a json list of region/species pairs\nlist &lt;- toJSON(speciesRegion, dataframe = \"rows\") # same as above\nlist &lt;- toJSON(speciesRegion, dataframe = \"columns\") # json object with a list of regions and a list of species\n\n# create JSON object manually \nregions &lt;- unique(speciesRegion$region)\nspecies &lt;- unique(speciesRegion$species)\nr &lt;- \"\"\ns &lt;- \"\"\n\n# make regions array {\"region1name\": [\"species1\", \"species2\"]}\nfor (x in 1:length(regions)) {\n  r &lt;- paste(r, '{\"name\": \"', regions[x], '\", \"values\": [')\n  listSpecies &lt;- speciesRegion[speciesRegion$region == regions[x], ] %&gt;% select(species)\n  uniqueSpecies &lt;- unique(listSpecies)\n  countSpecies &lt;- count(uniqueSpecies)\n  for (y in 1:countSpecies[1,1]) {\n    r &lt;- paste(r, '\"', uniqueSpecies[y, ], '\",')\n  }\n  r &lt;- substring(r, 1, nchar(r)-1)\n  r &lt;- paste(r, '], \"colour\": ')\n  # add \"ibra\" or \"imcra\" to colour\n  if( trimws(regions[x], \"both\") %in% ibraList) {\n    r &lt;- paste(r, '\"ibra\"')\n  } else if ( trimws(regions[x], \"both\") %in% imcraList ) {\n    r &lt;- paste(r, '\"imcra\"')\n  } else {\n    r &lt;- paste(r, '\"both\"')\n  }\n  r &lt;- paste(r, \"},\")\n}\n\n# make species array\nfor (a in 1:length(species)) {\n  s &lt;- paste(s, '{\"name\": \"', species[a], '\", \"values\": [')\n  listRegions &lt;- speciesRegion[speciesRegion$species == species[a], ] %&gt;% select(region)\n  uniqueRegions &lt;- unique(listRegions)\n  countRegions &lt;- count(uniqueRegions)\n  for (b in 1:countRegions[1,1]) {\n    s &lt;- paste(s, '\"', uniqueRegions[b, ], '\",')\n  }\n  s &lt;- substring(s, 1, nchar(s)-1)\n  s &lt;- paste(s, '], \"colour\": ')\n  # add class to species\n  speciesClass &lt;- speciesRegion[speciesRegion$species == species[a], ] %&gt;% select(class) \n  s &lt;- paste(s, '\"', speciesClass[1,1], '\"')\n  s &lt;- paste(s, \"},\")\n}\n# remove trailing commas\nr &lt;- substring(r, 1, nchar(r)-1)\ns &lt;- substring(s, 1, nchar(s)-1)\n\njsonObject &lt;- sprintf('{\"regions\": \n                      [%s], \n                      \"species\":\n                      [%s]}', r, s) \ncat(jsonObject, file=\"speciesRegion.json\")\n\n# get species class list to make colour scale in observable\nunique(speciesRegion$class)\n\n\n\nShape tweening - manipulating shape files and converting to JSON\nShape files for Australian states located at: https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files.\n\n###### Exploring state data for shape tweening\n\naggregateOccurrences &lt;- read.csv('AggregatedData_AustralianSpeciesOccurrences_1.1.2023-06-13.csv')\n\nlibrary(dplyr)\ntotal2022 &lt;- aggregateOccurrences %&gt;% \n  filter(year == 2022) %&gt;%\n  summarise(total2022 = sum(occurrrenceCount))\n\nstateCounts &lt;- (aggregateOccurrences %&gt;% \n                  filter(year == 2022) %&gt;%\n                  group_by(stateTerritory) %&gt;% \n                  summarise(signif(((sum(occurrenceCount)/total2022$total2022)*100), digits = 3)))\n\ncolnames(stateCounts)[colnames(stateCounts) == 'stateTerritory'] &lt;- 'name'\ncolnames(stateCounts)[2] &lt;- 'value'\n\n# subset data based on available shape files\nstateCounts &lt;- stateCounts %&gt;% filter(!((name == \"Unknown1\") | (name == \"Coral Sea Islands\") | (name == \"Ashmore and Cartier Islands\") | (name == \"\")))\n\nwrite.csv(stateCounts, \"C:\\\\Users\\\\PEE040\\\\OneDrive - CSIRO\\\\Documents\\\\EcoAssets\\\\BiodiversityData_2023\\\\Hobern_Donald_18_Dec_2023\\\\data\\\\stateCounts.csv\", row.names=FALSE)\n\n# Reading in a shape file and creating an array \n#install.packages(\"sf\")\nlibrary(sf)\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n# read in shape files using read_sf()\nshape &lt;- read_sf(\"states_shapes/STE_2021_AUST_GDA2020.shp\", promote_to_multi = FALSE)\n\n# Read in shape files using st_read() and cast multipolygons as polygons\nshape &lt;- st_read(\"states_shapes/STE_2021_AUST_GDA2020.shp\")\nshape2 &lt;- st_cast(shape, \"POLYGON\")\n\n# Read in shape file and simplify to reduce file size\nausShape &lt;- read_sf(\"states_shapes/STE_2021_AUST_GDA2020.shp\") \naus_simplified &lt;- ausShape |&gt;\n  filter(!(STE_NAME21 %in% c(\"Outside Australia\", \"Other Territories\"))) |&gt;\n  st_simplify(preserveTopology = TRUE, dTolerance = 1000)\n\nst_write(aus_simplified, \"path/to/STE_2021_AUST_GDA2020_simplified/STE_2021_AUST_GDA2020_simplified.shp\")\n\naus_simplified$geometry\n\nausShapeSimple &lt;- st_cast(aus_simplified, \"POLYGON\", group_or_split = TRUE, )\n\nausShapeSimple$geometry\n\n#st_union(ausShapeSimple |&gt; filter(STE_CODE21 == 1))\n\nausShapeSimple$area &lt;- st_area(ausShapeSimple)\n\nausShapeSimple &lt;- st_cast(aus_simplified, \"POLYGON\", group_or_split = TRUE) |&gt;\n  mutate(area = st_area(geometry)) |&gt;\n  arrange(STE_NAME21, desc(area)) |&gt; \n  group_by(STE_NAME21) |&gt;\n  filter(row_number() == 1)\n\nnswPolygons &lt;- ausShapeSimple |&gt; filter(STE_CODE21 == 1) \nsort(st_area(nswPolygons))\n\n# Save gemoetry as geojson file to be input into observable \n#install.packages(\"geojsonsf\")\nlibrary(geojsonsf)\ngeoShape &lt;- sf_geojson(ausShapeSimple)\n\nlibrary(jsonlite)\ncat(toJSON(geoShape), file = \"stateShapesOrdered.json\")\n\n\n\nExploring the Monitoring dataset\n\ndataSources &lt;- read.csv2('data-sources.csv', locale=locale(encoding=\"latin1\"))\n\naggregateData&lt;-read.csv('AggregatedData_EnvironmentalMonitoringAndObservationsEffort_1.1.2023-06-13.csv')\n\nsampleSet &lt;- aggregateData[sample(nrow(aggregateData), 5), ]\nsaveRDS(sampleSet, file=\"monitoring_sample.rds\")\n\nvocab &lt;- read.csv('Vocabulary_EcoAssetsEarthScienceFeatures_1.0.2023-03-23.csv')\n\nkeyWords &lt;- read.csv('KeywordMapping_EcoAssetsEarthScienceFeatures_1.0.2023-03-23.csv')\n\nfeatureID &lt;- unique(aggregateData$featureID)\nfeatureName &lt;- unique(aggregateData$featureName)\nfeature1 &lt;- unique(aggregateData$featureFacet1)\nfeature2 &lt;- unique(aggregateData$featureFacet2)\nfeature3 &lt;- unique(aggregateData$featureFacet3)\n\nsummaryTer &lt;- read.csv(\"SummaryData_MonitoringAndObservationsEffortByTerrestrialEcoregion_1.1.2023-06-13.csv\")\n\n## Data for Line graph of year and counts\nlibrary(dplyr)\nyearCounts &lt;- (aggregateData %&gt;% group_by(year) %&gt;% summarise(count=n()))\nyearCounts2 &lt;- (aggregateData %&gt;% group_by(year, nri) %&gt;% summarise(freq=n()))\nyearCounts3 &lt;- (aggregateData %&gt;% group_by(year, featureFacet3) %&gt;% summarise(count=n()))\nyearCounts4 &lt;- (aggregateData %&gt;% group_by(year, stateTerritory) %&gt;% summarise(count=n()))\n\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)\nggplot(data=yearCounts, aes(x=year, y=count, group=1)) + geom_line() + geom_point()\n\nggplot(data=yearCounts2, aes(x=year, y=freq, group=nri)) + geom_line(aes(color=nri)) + geom_point(aes(color=nri))\n\nggplot(data=yearCounts3, aes(x=year, y=count, group=featureFacet3)) + geom_line(aes(color=featureFacet3)) + geom_point(aes(color=featureFacet3))\n\nggplot(data=yearCounts4, aes(x=year, y=count, group=stateTerritory)) + geom_line(aes(color=stateTerritory)) + geom_point(aes(color=stateTerritory))"
  }
]