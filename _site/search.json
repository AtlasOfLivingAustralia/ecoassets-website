[
  {
    "objectID": "posts/first-news-post/post.html",
    "href": "posts/first-news-post/post.html",
    "title": "EcoAssets 2024 is up and running",
    "section": "",
    "text": "News Post 0\nThis is a test news post.\nExciting news! EcoAssets Quarto website has launched!\n\n\n\n\n Back to top"
  },
  {
    "objectID": "homepage.html",
    "href": "homepage.html",
    "title": "homepage",
    "section": "",
    "text": "&lt;!DOCTYPE html&gt;\n\n\n\n  \n\n\n\n\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"overlap-group\"&gt;\n    &lt;div class=\"rectangle\"&gt;&lt;/div&gt;\n    &lt;div class=\"text-wrapper\"&gt;Copyright&lt;/div&gt;\n    &lt;div class=\"text-wrapper-2\"&gt;Terms of use&lt;/div&gt;\n    &lt;div class=\"text-wrapper-3\"&gt;Privacy policy&lt;/div&gt;\n    &lt;div class=\"rectangle-2\"&gt;&lt;/div&gt;\n    &lt;p class=\"ecoassets-received\"&gt;\n      &lt;span class=\"span\"&gt;EcoAssets received investment (&lt;/span&gt;\n      &lt;a href=\"https://doi.org/10.47486/XN005\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"span\"&gt;doi.org/10.47486/XN005&lt;/span&gt;&lt;/a&gt;\n      &lt;span class=\"span\"&gt;) from the Australian Research Data Commons (ARDC). The ARDC is funded by the Australian Research Data\n        National Collaborative Research Infrastructure Strategy (NCRIS).&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;div class=\"frame\"&gt;\n      &lt;div class=\"logos\"&gt;\n        &lt;img class=\"img\" src=\"img/rectangle-10.png\" /&gt;\n        &lt;img class=\"rectangle-3\" src=\"img/rectangle-11.png\" /&gt;\n        &lt;img class=\"rectangle-4\" src=\"img/rectangle-12.png\" /&gt;\n        &lt;img class=\"rectangle-5\" src=\"img/rectangle-13.png\" /&gt;\n        &lt;img class=\"rectangle-6\" src=\"img/rectangle-14.png\" /&gt;\n        &lt;img class=\"rectangle-7\" src=\"img/rectangle-15.png\" /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;p class=\"acknowledgement-of\"&gt;\n      &lt;span class=\"text-wrapper-4\"&gt;Acknowledgement of Traditional Owners and Country&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-5\"\n        &gt;&lt;br /&gt;The project partners acknowledge Australia’s Traditional Owners and pay respect to the past and\n        present Elders of the nation’s Aboriginal and Torres Strait Islander communities. We honour and\n        celebrate the spiritual, cultural and customary connections of Traditional Owners to the country and the\n        biodiversity that forms part of that country.&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;img class=\"line\" src=\"img/line-1.svg\" /&gt;\n  &lt;/div&gt;\n  &lt;div class=\"rectangle-8\"&gt;&lt;/div&gt;\n&lt;/footer&gt;\n&lt;div class=\"news\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;News&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"&gt;View latest updates &gt; &lt;/span&gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"data\"&gt;\n  &lt;div class=\"explore-data-explore-wrapper\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Explore Data&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;Explore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and\n        TERN.&lt;br /&gt;&lt;br /&gt;See data &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"welcome\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Welcome to EcoAssets&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;EcoAssets brings together environmental data collected from three national research infrastructures –\n        the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the\n        information can be streamlined into integrated data assets to support Australia&#39;s environmental\n        reporting needs.&lt;br /&gt;&lt;br /&gt;Learn more &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;header class=\"header\"&gt;\n  &lt;div class=\"overlap-2\"&gt;\n    &lt;div class=\"title-background\"&gt;\n      &lt;div class=\"div-wrapper\"&gt;&lt;div class=\"text-wrapper-9\"&gt;EcoAssets&lt;/div&gt;&lt;/div&gt;\n      &lt;div class=\"rectangle-9\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"nav-bar\"&gt;\n      &lt;div class=\"overlap-3\"&gt;\n        &lt;div class=\"text-wrapper-10\"&gt;About&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"overlap-4\"&gt;\n        &lt;div class=\"text-wrapper-11\"&gt;Data&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down-2\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"text-wrapper-12\"&gt;News&lt;/div&gt;\n      &lt;img class=\"fi-bs-search\" src=\"img/fi-bs-search.svg\" /&gt;\n      &lt;img class=\"fi-bs-home\" src=\"img/fi-bs-home.svg\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/header&gt;\n&lt;img class=\"main-image\" src=\"img/main-image.png\" /&gt;"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About EcoAssets",
    "section": "",
    "text": "EcoAssets is improving access to integrated environmental data in forms that can support national, and state and territory environmental assessment and reporting activities. The project was established to support the authors of the 2021 Federal State of the Environment (SoE) report which reviews how different pressures are changing Australia’s land and marine environments and how these changes will impact the economy and society.\nAustralian environmental research infrastructures and their data partners collect large amounts of data each year on all aspects of the environment. In the past these data have not been integrated across infrastructures, or provided at a scale and in a format suitable for environmental reporting at national, or state and territory levels.\nThrough EcoAssets, three of Australia’s national research infrastructures - the ALA, IMOS and TERN - are working together to deliver open integrated data to support environmental assessment and reporting needs.\nThe key resulting data assets are: Integrated species distribution data asset Integrated survey and monitoring activity data asset EcoAssets is achieving these outcomes by identifying opportunities to increase alignment between data from all partners. In particular, we are simplifying spatiotemporal analyses and addressing differences in terminology and vocabularies."
  },
  {
    "objectID": "about.html#core-features",
    "href": "about.html#core-features",
    "title": "About EcoAssets",
    "section": "Core Features",
    "text": "Core Features\n\nImprovements to Data Pipelines\nEcoAssets will develop pipelines that offer standard views of the biodiversity component of data collected during TERN and IMOS field programmes for aggregation with ALA data streams.\n\n\nAggregation of Similar Data\nPartners will deliver and maintain high-value national data products that will serve as reference assets and a baseline for future environmental assessment. Data assets include species distribution, monitoring activity and growth in biodiversity knowledge. \n\n\nAlignment of Data Services\nThe newly aggregated data assets will provide a single set of data for major environmental products from the NCRIS infrastructures. This collection will feature standardised metadata, spatial and temporal units and other facets to support SoE reporting. The data assets will add significant value to future SoE reports (produced every 5 years), and other areas such as environmental accounting and impact assessments. \n\n\nData Principles: Findable, Accessible, Interoperable and Reusable (FAIR)\nData linkages and summary formats will provide easy-to-access information on indicators and trends. Data pipelines developed will enable future continuous updates and integration of new data from partners."
  },
  {
    "objectID": "about.html#partners",
    "href": "about.html#partners",
    "title": "About EcoAssets",
    "section": "Partners",
    "text": "Partners\n\n\n\n\n\nAtlas of Living Australia (ALA)\nThe Atlas of Living Australia (ALA) aggregates evidence of the distribution of Australian plant and animal species, bringing together data from museum specimens, field surveys, citizen science observations, molecular sequencing and literature. There are currently over 101 million freely available records held in the ALA.\n\n\n\n\n\nIntegrated Marine Observing System (IMOS)\nThe Integrated Marine Observing System (IMOS) operates a wide range of observing equipment throughout Australia’s coastal and open oceans, covering physical, chemical and biological variables. IMOS provides over 950 million freely available recorded ocean measurements.\n\n\n\n\n\nTerrestrial Ecosystem Research Network (TERN)\nTERN Australia advances research on anthropogenic impacts on land-based Australian ecosystems through provision of open access, standardised and integrated time-series data from its remote sensing, field observation and sensor monitoring across the continent. NCRIS\n\n\n\n\n\nAustralian Research Data Commons (ARDC)\nThe Australian Research Data Commons (ARDC) enables the Australian research community and industry access to nationally significant, data-intensive digital research infrastructure, platforms, skills and collections of high-quality data. The EcoAssets project received investment (https://doi.org/10.47486/XN005) from Australian Research Data Commons (ARDC), funded by The National Collaborative Research Infrastructure Strategy (NCRIS).\n\n\n\n\n\nAustralian Government\nDelivering the State of the Environment Report every five years, the Australian Government oversees national environmental interests in a broad range of areas such as environment and heritage, water resources, biosecurity, agriculture and the Antarctic.\n\n\n\n\n\n\n\n\nThe National Collaborative Research Infrastructure Strategy (NCRIS)\nThe ALA, IMOS, TERN and ARDC are made possible with funding from The National Collaborative Research Infrastructure Strategy (NCRIS)."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "About the Data",
    "section": "",
    "text": "EcoAssets Data explained\n1-2 sentences explaining the EcoAssets data, the difference between the datasets etc.\nlink to biodiversity page and monitoring page from here.\n\n100 + 10\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to EcoAssets",
    "section": "",
    "text": "Golden Stag Beetle"
  },
  {
    "objectID": "index.html#welcome-to-ecoassets",
    "href": "index.html#welcome-to-ecoassets",
    "title": "EcoAssets",
    "section": "Welcome to EcoAssets",
    "text": "Welcome to EcoAssets\nEcoAssets brings together environmental data collected from three national research infrastructures – the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the information can be streamlined into integrated data assets to support Australia’s environmental reporting needs.\nLearn more &gt;"
  },
  {
    "objectID": "index.html#explore-data",
    "href": "index.html#explore-data",
    "title": "EcoAssets",
    "section": "Explore Data",
    "text": "Explore Data\nExplore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and TERN.\nSee data &gt;"
  },
  {
    "objectID": "index.html#news",
    "href": "index.html#news",
    "title": "EcoAssets",
    "section": "News",
    "text": "News\n\n\n\n\n\n\n\n\nEcoAssets 2024 is up and running\n\n\nThe first news post of the website.\n\n\n\nClara Peers\n\n\nApr 1, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n\nView latest updates &gt;"
  },
  {
    "objectID": "news.html",
    "href": "news.html",
    "title": "News",
    "section": "",
    "text": "EcoAssets 2024 is up and running\n\n\nThe first news post of the website.\n\n\n\nClara Peers\n\n\nApr 1, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "about.html#about-us",
    "href": "about.html#about-us",
    "title": "About EcoAssets",
    "section": "",
    "text": "EcoAssets is improving access to integrated environmental data in forms that can support national, and state and territory environmental assessment and reporting activities. The project was established to support the authors of the 2021 Federal State of the Environment (SoE) report which reviews how different pressures are changing Australia’s land and marine environments and how these changes will impact the economy and society.\nAustralian environmental research infrastructures and their data partners collect large amounts of data each year on all aspects of the environment. In the past these data have not been integrated across infrastructures, or provided at a scale and in a format suitable for environmental reporting at national, or state and territory levels.\nThrough EcoAssets, three of Australia’s national research infrastructures - the ALA, IMOS and TERN - are working together to deliver open integrated data to support environmental assessment and reporting needs.\nThe key resulting data assets are: Integrated species distribution data asset Integrated survey and monitoring activity data asset EcoAssets is achieving these outcomes by identifying opportunities to increase alignment between data from all partners. In particular, we are simplifying spatiotemporal analyses and addressing differences in terminology and vocabularies."
  },
  {
    "objectID": "biodiversity_data.html#info-2",
    "href": "biodiversity_data.html#info-2",
    "title": "EcoAssets",
    "section": "info 2",
    "text": "info 2"
  },
  {
    "objectID": "biodiversity_data.html#info-3",
    "href": "biodiversity_data.html#info-3",
    "title": "EcoAssets",
    "section": "info 3",
    "text": "info 3"
  },
  {
    "objectID": "biodiversity_data.html",
    "href": "biodiversity_data.html",
    "title": "EcoAssets",
    "section": "",
    "text": "Figure 1\n\n`Threatened Status of species from the year ${selectedYear} to the year ${selectedYearEnd}`\n\n\n\n\n\n\n\nimcraData = FileAttachment(\"data/SummaryData-ThreatenedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\nibraData = FileAttachment(\"data/SummaryData-ThreatenedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\n\ncombinedData = Promise.all(\n  [imcraData,\n  ibraData]\n).then(\n  ([data1, data2]) =&gt; {\n    return data1.concat(data2)\n  }\n)\n\nPlot.plot({\n  color: { legend: true, scheme: \"Rainbow\" },\n  marks: [\n    Plot.barY(\n      year,\n      Plot.groupX(\n        { y: \"count\" },\n        { x: \"epbcStatus\", fill: \"epbcStatus\", tip: true }\n      )\n    ),\n    Plot.ruleY([0])\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof year = Inputs.radio(d3.group(combinedData, d =&gt; d.yearStart), {label: \"Year\", sort: \"ascending\", value:'2016'})\n\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nselectedYear = year[0][\"yearStart\"]\n\nselectedYearEnd = year[0][\"yearEnd\"]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTime-out error: WARNING: error writing a body to connection: An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. (os error 10055): An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. (os error 10055)\n\n\nFigure 2\n\n\nLink to access data\nLink to CSIRO data portal to access data.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "biodiversity_data.html#figure-1",
    "href": "biodiversity_data.html#figure-1",
    "title": "EcoAssets",
    "section": "",
    "text": "imcraData = FileAttachment(\"SummaryData-ThreatenedSpeciesOccurrencesByMarineEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\nibraData = FileAttachment(\"SummaryData-ThreatenedSpeciesOccurrencesByTerrestrialEcoregion-1.1.2023-06-13.csv\").csv({ typed: true })\n\ncombinedData = Promise.all(\n  [imcraData,\n  ibraData]\n).then(\n  ([data1, data2]) =&gt; {\n    return data1.concat(data2)\n  }\n)\n\nPlot.plot({\n  color: { legend: true, scheme: \"Rainbow\" },\n  marks: [\n    Plot.barY(\n      year,\n      Plot.groupX(\n        { y: \"count\" },\n        { x: \"epbcStatus\", fill: \"epbcStatus\", tip: true }\n      )\n    ),\n    Plot.ruleY([0])\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof year = Inputs.radio(d3.group(combinedData, d =&gt; d.yearStart), {label: \"Year\", sort: \"ascending\", value:[498]})\n\nselectedYear = year[0][\"yearStart\"]\n\nselectedYearEnd = year[0][\"yearEnd\"]"
  },
  {
    "objectID": "biodiversity_data.html#figure-2",
    "href": "biodiversity_data.html#figure-2",
    "title": "EcoAssets",
    "section": "Figure 2",
    "text": "Figure 2"
  },
  {
    "objectID": "monitoring_data.html",
    "href": "monitoring_data.html",
    "title": "EcoAssets",
    "section": "",
    "text": "Visualisations\nMonitoring data viz here, with explanation.\n\n\nLink to Access Data\nLink to CSIRO data portal to access monitoring dataset.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "dataStory0.html",
    "href": "dataStory0.html",
    "title": "Data Story 0",
    "section": "",
    "text": "As demo’ed here : https://github.com/jimjam-slam/quarto-experiments/blob/main/scrollytelling/index.qmd.\n\n\nThis\nis\na\nlong\ncolumn\nof text\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nv\ne\nr\ny\nl\no\nn\ng\n.\n\n\n\nThis whole column has position:sticky; and top:100px on it!\n\nFIGURE\n\n\n\n\n\n\n\n\nA beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "dataStory0.html#demo-sticky-overlay",
    "href": "dataStory0.html#demo-sticky-overlay",
    "title": "Data Story 0",
    "section": "",
    "text": "A beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "d3Chart.html",
    "href": "d3Chart.html",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "d3Chart.html#a-d3-chart",
    "href": "d3Chart.html#a-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "d3Chart.html#an-interactive-seal",
    "href": "d3Chart.html#an-interactive-seal",
    "title": "A custom d3 visualisation",
    "section": "An interactive Seal",
    "text": "An interactive Seal\nThis was made with: https://robisateam.github.io/courses/web-course/5-javascript\n\n  \n\n\nFeed\nSwim\n\nseal_image = document.getElementById('seal');\nfeed_button = document.getElementById('feed-button')\nswim_button = document.getElementById('swim-button')\n\n// detect if someone clicks on the image -&gt; event listeners constantly check if someone performs a certain action\n// event listener takes 2 args: the type of event and a callback\n// callback: a function that explains what we want it to do when the event fires -&gt; in this case, execute a function called cricket\n//beetle_image.addEventListener(\"click\", cricket);\n\nfunction roar() {\n  alert(\"roooaaaaar\");\n};\n\n// create an inline function to execute a sequence of functions -&gt; only defined in the scope of this specific callback\nseal_image.addEventListener(\"click\", function() {\n  roar();\n  //scratch();\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfeed_button.addEventListener(\"click\", feed);\n\n\n\n\n\n\n\nfunction feed() {\n  seal_image.style.height = (seal_image.offsetHeight + 30.0) + 'px';\n};\nswim_button.addEventListener(\"dblclick\", function() {\n  seal_image.style.height = (seal_image.offsetHeight - 30.0) + 'px'\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = [10, 20, 30];\nconsole.log(data);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_object0 = ({name:\"cat\", weight: 10});\ncat_object = ({weight : 5, past_weight_values : 5, name : \"Princess Caroline\"});\n\ncat_list = [cat_object]; // initializing with the first field being cat_object\ncat_list.push({weight : 6 , past_weight_values : [5.9, 5.3, 6.1], name : \"Snowball\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_list.push({weight : 2})\n\n\n\n\n\n\n\nconsole.log(cat_list)"
  },
  {
    "objectID": "d3Chart.html#another-d3-chart",
    "href": "d3Chart.html#another-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "Another D3 Chart",
    "text": "Another D3 Chart\nFrom this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n////////////////////// Set up Chart\n\n\n////////////////////// Create Axes\n\n\n////////////////////// Plot Data \n\nPlot.plot({\n  width: 300,\n  height: 240,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 20] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      currentData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html",
    "href": "d3Chart2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#another-d3-chart",
    "href": "d3Chart2.html#another-d3-chart",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n////////////////////// Set up Chart\n\n\n////////////////////// Create Axes\n\n\n////////////////////// Plot Data \n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "href": "d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "d3Chart2.html#and-now-some-scrollytelling",
    "href": "d3Chart2.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n\n\n```{ojs}\n\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 240, column 84)Unexpected token"
  },
  {
    "objectID": "d3Chart2.html#lets-try-again",
    "href": "d3Chart2.html#lets-try-again",
    "title": "Another visualisation",
    "section": "Let’s try again",
    "text": "Let’s try again\n\n```{ojs}\n\nimport ScrollyTeller from 'ScrollyTeller.js';\n\nstoryConfiguration = ({\n  appContainerId: 'app',\n  sectionList: [\n    intro,\n    wealthAndHealthConfig,\n    builtInTriggers,\n  ]\n});\n\nstoryInstance = new ScrollyTeller(storyConfiguration)\n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 281, column 8)Unexpected token"
  },
  {
    "objectID": "stories/dataStory0.html",
    "href": "stories/dataStory0.html",
    "title": "Data Story 0",
    "section": "",
    "text": "As demo’ed here : https://github.com/jimjam-slam/quarto-experiments/blob/main/scrollytelling/index.qmd.\n\n\nThis\nis\na\nlong\ncolumn\nof text\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nvery\nv\ne\nr\ny\nl\no\nn\ng\n.\n\n\n\nThis whole column has position:sticky; and top:100px on it!\n\nFIGURE\n\n\n\n\n\n\n\n\nA beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "stories/dataStory0.html#demo-sticky-overlay",
    "href": "stories/dataStory0.html#demo-sticky-overlay",
    "title": "Data Story 0",
    "section": "",
    "text": "A beetle\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut accumsan rhoncus turpis, id condimentum augue dignissim vel. Suspendisse varius ex nec ligula dictum, vel vestibulum felis bibendum. Cras id mauris posuere, tempus quam at, vehicula eros. Mauris lobortis ante at dapibus blandit. Praesent hendrerit purus quis urna auctor congue. Etiam ut purus mattis, fringilla magna ac, rhoncus enim. Maecenas luctus turpis nisl, sit amet efficitur mauris viverra vel. In dignissim vehicula nunc, vel scelerisque ante. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla ac pulvinar justo. Sed quis felis odio. Aliquam erat volutpat. Duis ornare ligula tincidunt, volutpat erat in, tristique enim. Nullam id neque sed odio consectetur imperdiet. Cras non malesuada enim, eget hendrerit nunc.\nSuspendisse at diam a purus dictum bibendum. Sed eu volutpat sem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque at porttitor leo. Mauris laoreet nibh arcu, hendrerit posuere quam auctor eget. Quisque vulputate felis et bibendum dapibus. Ut varius in risus nec finibus. Sed vitae nisl in nisl gravida consectetur. Maecenas ac libero non arcu ultricies porta non sit amet lorem.\nCras ac euismod quam. Proin tempor hendrerit ullamcorper. Aliquam eu elementum neque. Nunc purus dui, fringilla quis pretium vitae, accumsan eget massa. Pellentesque dignissim justo nec velit ullamcorper accumsan. Proin ultrices nisi ac convallis varius. Morbi at leo nisl. Nam condimentum quis mi sed ultricies. Sed vel diam dictum, scelerisque enim sit amet, feugiat nibh. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean at tortor vel ipsum suscipit porta."
  },
  {
    "objectID": "stories/d3Chart2.html",
    "href": "stories/d3Chart2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "href": "stories/d3Chart2.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/d3Chart2.html#and-now-some-scrollytelling",
    "href": "stories/d3Chart2.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n\n```{ojs}\n\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 237, column 84)Unexpected token"
  },
  {
    "objectID": "stories/homepage.html",
    "href": "stories/homepage.html",
    "title": "homepage",
    "section": "",
    "text": "&lt;!DOCTYPE html&gt;\n\n\n\n  \n\n\n\n\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"overlap-group\"&gt;\n    &lt;div class=\"rectangle\"&gt;&lt;/div&gt;\n    &lt;div class=\"text-wrapper\"&gt;Copyright&lt;/div&gt;\n    &lt;div class=\"text-wrapper-2\"&gt;Terms of use&lt;/div&gt;\n    &lt;div class=\"text-wrapper-3\"&gt;Privacy policy&lt;/div&gt;\n    &lt;div class=\"rectangle-2\"&gt;&lt;/div&gt;\n    &lt;p class=\"ecoassets-received\"&gt;\n      &lt;span class=\"span\"&gt;EcoAssets received investment (&lt;/span&gt;\n      &lt;a href=\"https://doi.org/10.47486/XN005\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"span\"&gt;doi.org/10.47486/XN005&lt;/span&gt;&lt;/a&gt;\n      &lt;span class=\"span\"&gt;) from the Australian Research Data Commons (ARDC). The ARDC is funded by the Australian Research Data\n        National Collaborative Research Infrastructure Strategy (NCRIS).&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;div class=\"frame\"&gt;\n      &lt;div class=\"logos\"&gt;\n        &lt;img class=\"img\" src=\"img/rectangle-10.png\" /&gt;\n        &lt;img class=\"rectangle-3\" src=\"img/rectangle-11.png\" /&gt;\n        &lt;img class=\"rectangle-4\" src=\"img/rectangle-12.png\" /&gt;\n        &lt;img class=\"rectangle-5\" src=\"img/rectangle-13.png\" /&gt;\n        &lt;img class=\"rectangle-6\" src=\"img/rectangle-14.png\" /&gt;\n        &lt;img class=\"rectangle-7\" src=\"img/rectangle-15.png\" /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;p class=\"acknowledgement-of\"&gt;\n      &lt;span class=\"text-wrapper-4\"&gt;Acknowledgement of Traditional Owners and Country&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-5\"\n        &gt;&lt;br /&gt;The project partners acknowledge Australia’s Traditional Owners and pay respect to the past and\n        present Elders of the nation’s Aboriginal and Torres Strait Islander communities. We honour and\n        celebrate the spiritual, cultural and customary connections of Traditional Owners to the country and the\n        biodiversity that forms part of that country.&lt;/span\n      &gt;\n    &lt;/p&gt;\n    &lt;img class=\"line\" src=\"img/line-1.svg\" /&gt;\n  &lt;/div&gt;\n  &lt;div class=\"rectangle-8\"&gt;&lt;/div&gt;\n&lt;/footer&gt;\n&lt;div class=\"news\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;News&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"&gt;View latest updates &gt; &lt;/span&gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"data\"&gt;\n  &lt;div class=\"explore-data-explore-wrapper\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Explore Data&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;Explore the latest aggregated datasets for biodiversity and monitoring data from the ALA, IMOS and\n        TERN.&lt;br /&gt;&lt;br /&gt;See data &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"welcome\"&gt;\n  &lt;div class=\"overlap\"&gt;\n    &lt;p class=\"p\"&gt;\n      &lt;span class=\"text-wrapper-6\"&gt;Welcome to EcoAssets&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-7\"&gt;&lt;br /&gt;&lt;/span&gt;\n      &lt;span class=\"text-wrapper-8\"\n        &gt;EcoAssets brings together environmental data collected from three national research infrastructures –\n        the ALA, IMOS and TERN. By standardising the formats of these data resources and then sharing them, the\n        information can be streamlined into integrated data assets to support Australia&#39;s environmental\n        reporting needs.&lt;br /&gt;&lt;br /&gt;Learn more &gt;&lt;/span\n      &gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;header class=\"header\"&gt;\n  &lt;div class=\"overlap-2\"&gt;\n    &lt;div class=\"title-background\"&gt;\n      &lt;div class=\"div-wrapper\"&gt;&lt;div class=\"text-wrapper-9\"&gt;EcoAssets&lt;/div&gt;&lt;/div&gt;\n      &lt;div class=\"rectangle-9\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"nav-bar\"&gt;\n      &lt;div class=\"overlap-3\"&gt;\n        &lt;div class=\"text-wrapper-10\"&gt;About&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"overlap-4\"&gt;\n        &lt;div class=\"text-wrapper-11\"&gt;Data&lt;/div&gt;\n        &lt;img class=\"fi-bs-caret-down-2\" src=\"img/fi-bs-caret-down.svg\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"text-wrapper-12\"&gt;News&lt;/div&gt;\n      &lt;img class=\"fi-bs-search\" src=\"img/fi-bs-search.svg\" /&gt;\n      &lt;img class=\"fi-bs-home\" src=\"img/fi-bs-home.svg\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/header&gt;\n&lt;img class=\"main-image\" src=\"img/main-image.png\" /&gt;\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "stories/d3Chart.html",
    "href": "stories/d3Chart.html",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "stories/d3Chart.html#a-d3-chart",
    "href": "stories/d3Chart.html#a-d3-chart",
    "title": "A custom d3 visualisation",
    "section": "",
    "text": "This was made following this tutorial: https://robisateam.github.io/courses/d3-course\n\n  The Wealth & Health of Nations\n  \n\n\n\n  \n\n  \n   Sub-Saharan Africa\n  \n  \n   \n\n\nchart_area = d3.select(\"#chart_area\");\n\n// set up the picture frame inside the chart area\nframe = chart_area.append(\"svg\");\n\n// set up the canvas (drawing area) within the frame\ncanvas = frame.append(\"g\");\n\n// set up dimensions for the elements to use\nmargin = ({top: 19.5, right: 19.5, bottom: 19.5, left: 39.5});\nframe_width = 960;\nframe_height = 350;\ncanvas_width = frame_width - margin.left - margin.right;\ncanvas_height = frame_height - margin.top - margin.bottom; \nframe.attr(\"width\", frame_width);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nframe.attr(\"height\", frame_height);\n\n\n\n\n\n\n\ncanvas.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n\n\n\n\n\ncanvas.attr(\"width\", canvas_width);\n\n\n\n\n\n\n\ncanvas.attr(\"height\", canvas_height);\n\n\n\n\n\n\n\nnations_data = (await FileAttachment(\"nations.json\").json());\n\nnations_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof regions = Inputs.checkbox([\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], \n  {value: [\"Sub-Saharan Africa\", \"South Asia\", \"Middle East & North Africa\", \"America\", \"Europe & Central Asia\", \"East Asia & Pacific\"], label: \"Regions\"})\n\nregions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered_nations = nations_data.filter( (d) =&gt; regions.includes(d.region));\n\nfiltered_nations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale = d3.scaleLog();   // could also use scaleLinear, scaleSqrt, schemeCategory20 ... \n\n// set min and max value -&gt; data values that will get mapped to the min and max positions on the page, specified by the range below\nxScale.domain([250, 1e5]);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxScale.range([0, canvas_width]);\n\n\n\n\n\n\n\nxAxis = d3.axisBottom(xScale); \n\n// push x axis to canvas and position\ncanvas.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + canvas_height + \")\")    // move axis to bottom of  plotting area by using transform --&gt; there are a options, use translate to shift it\n  .call(xAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyScale = d3.scaleLinear().domain([10, 85]).range([canvas_height, 0]);\nyAxis = d3.axisLeft(yScale);\ncanvas.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(yAxis);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrScale = d3.scaleSqrt().domain([0, 5e8]).range([0, 40]);\n\ncolorScale = d3.scaleOrdinal(d3.schemeSet2);\ncolorScale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_canvas = canvas.append(\"g\").attr(\"class\", \"data_canvas\");\n\n// select everything of the class dot - an empty set, but then get the data from nations dataset and insert a key function \n// key function helps d3 keep track of data when you start changing it - need to keep ID unique (use name of element)\ndot = data_canvas.selectAll(\".dot\").data(filtered_nations, function(d){return d.name});\n\n// enter function takes each element in the dataset and does everything after it to all elements\n// create one circle for each data point: cx & cy are based on income and life expectancy \ndot.enter().append(\"circle\").attr(\"class\", \"dot\")\n  .style(\"fill\", function(d){return colorScale(d.region); })\n  .attr(\"cx\", function(d){return xScale(d.income[d.income.length-1]); })\n  .attr(\"cy\", function(d){return yScale(d.lifeExpectancy[d.lifeExpectancy.length-1]); })\n  .attr(\"r\", function(d){return rScale(d.population[d.population.length-1]); });"
  },
  {
    "objectID": "stories/d3Chart.html#an-interactive-seal",
    "href": "stories/d3Chart.html#an-interactive-seal",
    "title": "A custom d3 visualisation",
    "section": "An interactive Seal",
    "text": "An interactive Seal\nThis was made with: https://robisateam.github.io/courses/web-course/5-javascript\n\n  \n\n\nFeed\nSwim\n\nseal_image = document.getElementById('seal');\nfeed_button = document.getElementById('feed-button')\nswim_button = document.getElementById('swim-button')\n\n// detect if someone clicks on the image -&gt; event listeners constantly check if someone performs a certain action\n// event listener takes 2 args: the type of event and a callback\n// callback: a function that explains what we want it to do when the event fires -&gt; in this case, execute a function called cricket\n//beetle_image.addEventListener(\"click\", cricket);\n\nfunction roar() {\n  alert(\"roooaaaaar\");\n};\n\n// create an inline function to execute a sequence of functions -&gt; only defined in the scope of this specific callback\nseal_image.addEventListener(\"click\", function() {\n  roar();\n  //scratch();\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfeed_button.addEventListener(\"click\", feed);\n\n\n\n\n\n\n\nfunction feed() {\n  seal_image.style.height = (seal_image.offsetHeight + 30.0) + 'px';\n};\nswim_button.addEventListener(\"dblclick\", function() {\n  seal_image.style.height = (seal_image.offsetHeight - 30.0) + 'px'\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = [10, 20, 30];\nconsole.log(data);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_object0 = ({name:\"cat\", weight: 10});\ncat_object = ({weight : 5, past_weight_values : 5, name : \"Princess Caroline\"});\n\ncat_list = [cat_object]; // initializing with the first field being cat_object\ncat_list.push({weight : 6 , past_weight_values : [5.9, 5.3, 6.1], name : \"Snowball\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncat_list.push({weight : 2})\n\n\n\n\n\n\n\nconsole.log(cat_list)"
  },
  {
    "objectID": "stories/exampleStory.html",
    "href": "stories/exampleStory.html",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/exampleStory.html#wealth-and-health-of-nations-on-plot",
    "href": "stories/exampleStory.html#wealth-and-health-of-nations-on-plot",
    "title": "Another visualisation",
    "section": "",
    "text": "From this link: https://observablehq.com/@tophtucker/the-wealth-health-of-nations\n\nfunction parseSeries(series) {\n  return series.map(([year, value]) =&gt; [new Date(Date.UTC(year, 0, 1)), value]);\n}\n\n// map creates a new array from calling a function for every array element, without changing the original array \ndata = (await FileAttachment(\"nations2.json\").json())\n  .map(({name, region, income, population, lifeExpectancy}) =&gt; ({\n    name,\n    region,\n    income: parseSeries(income),\n    population: parseSeries(population),\n    lifeExpectancy: parseSeries(lifeExpectancy)\n  }))\n\n// ... is Spread syntax in Javascript (or Spread operator) --&gt; allows an iterable to be expanded \n// without this, the new set created just has a single object which is an array of 180 objects --&gt; ie you get a nested output\n// Array: a block of data allocated in consecutive memory [x, y, z] --&gt; indexed collection\n// Set: abstract data type with only distinct elements/objects that don't need to be allocated by index {x, y, z} --&gt; keyed collection\ncountries = [...new Set(data.map(d =&gt; d.name))].sort()\n\nregions = new Set(data.map(d =&gt; d.region))\n\n////// Update data for user input\n\n// Bisection (binary search) quickly finds a given value in a sorted array\n// finds the index of the row for the specified date\nbisectDate = d3.bisector(([date]) =&gt; date).left \n\n// given an array and specified year (date), returns the value in the array for that year\nfunction valueAt(values, date) {\n  const i = bisectDate(values, date, 0, values.length - 1);\n  const a = values[i];\n  if (i &gt; 0) {\n    const b = values[i - 1];\n    const t = (date - a[0]) / (b[0] - a[0]);\n    return a[1] * (1 - t) + b[1] * t;\n  }\n  return a[1];\n}\n\n// select data at specified year ie get only one data point for each field\nfunction dataAt(date) {\n  return data.map(d =&gt; ({\n    name: d.name,\n    region: d.region,\n    income: valueAt(d.income, date),\n    population: valueAt(d.population, date),\n    lifeExpectancy: valueAt(d.lifeExpectancy, date)\n  }));\n}\n\n// get only data selected by user \ndisplayData = dataAt(new Date(Date.UTC(year, 0, 1)))\n\n// Inputs\n// First get range of years\ndateExtent = [\n  d3.min(data, (d) =&gt; {\n    return d3.min(\n      [d.income[0], d.population[0], d.lifeExpectancy[0]],\n      ([date]) =&gt; date\n    );\n  }),\n  d3.min(data, (d) =&gt; {\n    return d3.max(\n      [\n        d.income[d.income.length - 1],\n        d.population[d.population.length - 1],\n        d.lifeExpectancy[d.lifeExpectancy.length - 1]\n      ],\n      ([date]) =&gt; date\n    );\n  })\n]\n\nviewof year = Inputs.range(\n  dateExtent.map((d) =&gt; d.getUTCFullYear()),\n  { label: \"Year\", step: 1, value: dateExtent[0].getUTCFullYear() }\n)\n\nviewof country = Inputs.select([\"—\", ...countries], {label: \"Highlight\"})\n\nviewof selectedRegions = Inputs.checkbox(regions, {value: regions, label: \"Regions\"})\n\n\nPlot.plot({\n  width: 900,\n  height: 720,\n  x: { type: \"log\", label: \"Income per capita (dollars)\", domain: [200, 1e5] },\n  y: { label: \"Life expectancy (years)\", domain: [14, 86] },\n  r: { domain: [0, 5e8], range: [0, 60] },\n  color: { domain: regions },\n  marks: [\n    Plot.dot(\n      displayData\n        .filter((d) =&gt; selectedRegions.includes(d.region))\n        .sort((a, b) =&gt; b.population - a.population),\n      {\n        x: \"income\",\n        y: \"lifeExpectancy\",\n        r: \"population\",\n        z: \"name\",\n        fill: \"region\",\n        stroke: \"rgba(0, 0, 0, 0.2)\",\n        strokeWidth: 1,\n        opacity: (d) =&gt; (country === \"—\" || d.name === country ? 1 : 0.2)\n      }\n    )\n  ]\n})"
  },
  {
    "objectID": "stories/exampleStory.html#and-now-some-scrollytelling",
    "href": "stories/exampleStory.html#and-now-some-scrollytelling",
    "title": "Another visualisation",
    "section": "And now some scrollytelling",
    "text": "And now some scrollytelling\n\n// instance of CSSNames class\n// Can be used to override the default naming of id's and css classes. If left undefined, the default naming will be used.\n\nclass CSSNames {\n  /*scrollContainer= \"scroll\",\n  sectionContainer= 'section',\n  narrationList= 'narration_list',\n  narrationBlock= 'narration',\n  narrationContent= 'narration-content',\n  graphContainer= 'graph',\n  graphContainerDefault= 'graph_default',\n  graphTitleClass= 'graph_title',\n  graphCaptionClass= 'graph_caption',\n  linkContainer= 'link',*/\n  \n  constructor() {\n    this.scrollContainer= 'scroll',\n    this.sectionContainer= 'section',\n    this.narrationList= 'narration_list',\n    this.narrationBlock= 'narration',\n    this.narrationContent= 'narration-content',\n    this.graphContainer= 'graph',\n    this.graphContainerDefault= 'graph_default',\n    this.graphTitleClass= 'graph_title',\n    this.graphCaptionClass= 'graph_caption',\n    this.linkContainer= 'link'\n  }\n};\n\n\n\n\n\n\n\nscrollyteller = require('@ihmeuw/scrollyteller@1.0.2');\nlodash = import('https://unpkg.com/lodash-es@4.17.21/lodash.js?module');\n// intro = FileAttachment(\"exampleStory/00_intro/scrollyTellerConfig.js\");\n\n\n// A helper function\nupdateSvgImage = (graphId, state, previousSvgFileName) =&gt; {\n  const {\n    svgFileName,\n  } = state;\n  if (lodash.isNil(svgFileName)) {\n    const graph = d3.select(`#${graphId} .imageDiv`);\n    graph\n      .transition()\n      .duration(250)\n      .style('opacity', 0);\n  }\n  if (svgFileName !== previousSvgFileName) {\n    const html = svgFileName\n      ? `&lt;img src=\"dist/images/${svgFileName}.svg\" /&gt;`\n      : null;\n    const graph = d3.select(`#${graphId} .imageDiv`);\n    graph\n      .transition()\n      .duration(250)\n      .style('opacity', 0)\n      .on('end', () =&gt; {\n        graph\n          .html(html)\n          .transition()\n          .duration(250)\n          .style('opacity', svgFileName ? 1 : 0);\n      });\n  }\n};\n\n// local state object- constant \nsectionState = ({svgFileName: ''});\n\n/* CSSNames = ({\n  scrollContainer: 'scroll',\n  sectionContainer: 'section',\n  narrationList: 'narration_list',\n  narrationBlock: 'narration',\n  narrationContent: 'narration-content',\n  graphContainer: 'graph',\n  graphContainerDefault: 'graph_default',\n  graphTitleClass: 'graph_title',\n  graphCaptionClass: 'graph_caption',\n  linkContainer: 'link',\n}); */\n\nintro = ({\n  sectionIdentifier: 'introduction',\n\n  /** narration can be either of the following 3 options:\n   *  1) a string representing an absolute file path to a file of the following types:\n   *      'csv', 'tsv', 'json', 'html', 'txt', 'xml', which will be parsed by d3.promise\n   *  2) array of narration objects,\n   *  3) a promise to return an array of narration objects in the appropriate form\n   * See README for the specification of the narration objects */\n  narration: FileAttachment(\"narration.csv\").csv(),\n\n  data: [],\n  \n  convertTriggerToObject: true,\n  \n  // css names - not required but prevents bugs\n   cssNames : new CSSNames(),\n  /**\n   * Optional method to reshape the data passed into ScrollyTeller, or resolved by the data promise\n   * @param {object} results - data passed into ScrollyTeller or the result of resolving the data promise (see below).\n   * @returns {object|array} -  an object or array of data of user-defined shape\n   */\n  reshapeDataFunction: function processData(results) {\n    return {};\n  },\n  \n   /**\n   * Called AFTER data is fetched, and reshapeDataFunction is called.  This method should\n   * build the graph and return an instance of that graph, which will passed as arguments\n   * to the onScrollFunction and onActivateNarration functions.\n   *\n   * This function is called as follows:\n   * buildGraphFunction(graphId, sectionConfig)\n   * @param {string} graphId - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} sectionConfig - the configuration object passed to ScrollyTeller\n   * @param {object} [sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {object} - chart instance\n   */\n  buildGraphFunction: function buildGraph(graphId, sectionConfig) {\n    /** REMEMBER TO RETURN THE GRAPH! (could also return as an object with multiple graphs, etc)\n     * The graph object is assigned to sectionConfig.graph, which is returned to all scrollyteller\n     * functions such as buildGraphFunction(), onActivateNarrationFunction(), onScrollFunction()  */\n    d3.select(`#${graphId}`)\n      .append('div')\n      .classed('imageDiv', true)\n    updateSvgImage(graphId, { svgFileName: 'slide1' }, sectionState.svgFileName);\n    sectionState.svgFileName = 'slide1';\n    return undefined;\n  },\n\n  /**\n   * Called upon scrolling of the section. See argument list below, this function is called as:\n   * onScrollFunction({ index, progress, element, trigger, graphId, sectionConfig })\n   * @param {object} [params] - object containing parameters\n   * @param {number} [params.index] - index of the active narration object\n   * @param {number} [params.progress] - 0-1 (sort of) value indicating progress through the active narration block\n   * @param {HTMLElement} [params.element] - the narration block DOM element that is currently active\n   * @param {string} [params.trigger] - the trigger attribute for narration block that is currently active\n   * @param {string} [params.graphContainerId] - id of the graph container in this section. const graphContainer = d3.select(`#${graphContainerId}`);\n   * @param {string} [params.graphId] - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} [params.sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [params.sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [params.sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [params.sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [params.sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [params.sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {void}\n   */\n  onScrollFunction: function onScroll() {\n  },\n  \n  /**\n   * Called when a narration block is activated.\n   * See argument list below, this function is called as:\n   * onActivateNarration({ index, progress, element, trigger, graphId, sectionConfig })\n   * @param {object} [params] - object containing parameters\n   * @param {number} [params.index] - index of the active narration object\n   * @param {number} [params.progress] - 0-1 (sort of) value indicating progress through the active narration block\n   * @param {HTMLElement} [params.element] - the narration block DOM element that is currently active\n   * @param {string} [params.trigger] - the trigger attribute for narration block that is currently active\n   * @param {string} [params.direction] - the direction the event happened in (up or down)\n   * @param {string} [params.graphContainerId] - id of the graph container in this section. const graphContainer = d3.select(`#${graphContainerId}`);\n   * @param {string} [params.graphId] - id of the graph in this section. const myGraph = d3.select(`#${graphId}`);\n   * @param {object} [params.sectionConfig] - the configuration object passed to ScrollyTeller\n   * @param {string} [params.sectionConfig.sectionIdentifier] - the identifier for this section\n   * @param {object} [params.sectionConfig.graph] - the chart instance, or a reference containing the result of the buildChart() function above\n   * @param {object} [params.sectionConfig.data] - the data that was passed in or resolved by the promise and processed by reshapeDataFunction()\n   * @param {object} [params.sectionConfig.scroller] - the scrollama object that handles activation of narration, etc\n   * @param {object} [params.sectionConfig.cssNames] - the CSSNames object containing some useful functions for getting the css identifiers of narrations, graph, and the section\n   * @param {object} [params.sectionConfig.elementResizeDetector] - the element-resize-detector object: see https://github.com/wnr/element-resize-detector for usage\n   * @returns {void}\n   */\n  onActivateNarrationFunction: function onActivateNarration({\n    graphId,\n    state,\n    state: {\n      svgFileName,\n    },\n  }) {\n    /** DISPLAY/FLIP BETWEEN IMAGES */\n    updateSvgImage(graphId, state, sectionState.svgFileName);\n    sectionState.svgFileName = svgFileName;\n  },\n\n});\n\nintro.cssNames.constructor.name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstoryConfiguration = ({\n  /* The id of the &lt;div&gt; that will contain all of the page content */\n  appContainerId: \"app\",\n  /*build an array of story sections, each section object should be a valid ScrollyTeller section configuration */\n  sectionList: [intro],\n});\n\nstoryConfiguration.sectionList[0].cssNames.constructor.name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsi = new scrollyteller.default(storyConfiguration);\n\n/* parse data and build all HMTL */\nsi.render();"
  },
  {
    "objectID": "stories/ECharts.html",
    "href": "stories/ECharts.html",
    "title": "Sample GeoMap with ECharts",
    "section": "",
    "text": "Sample GeoMap with ECharts\n–&gt; add this above echo: jupyter: python3\nFrom this site: https://medium.com/@emmanueldavidson/creating-beautiful-analytics-documents-with-quarto-and-observable-js-a4a746f8793a\nIn this example, we’re creating a GeoMap visualization using ECharts and embedding it within an Observable.js cell in a Quarto document. Let’s break down how this integration works:\nQuarto Document Structure: We start with the Quarto document structure. Quarto allows you to use a combination of Markdown and code chunks to structure your content. Observable.js Cell: Within the document, we use the {ojs} code chunk to define an Observable.js cell. This cell contains JavaScript code for creating our interactive GeoMap. JavaScript Code: Inside the Observable.js cell, we write JavaScript code to customize our GeoMap. This includes defining functions, processing data, and configuring the map using ECharts. Dynamic Visualization: Observable.js allows us to create dynamic and interactive visualizations. The code interacts with the DOM to render the GeoMap within an HTML div element. External Libraries: We can import external libraries like ECharts using JavaScript’s require function. This allows us to leverage powerful visualization libraries within our document. Data Import: Observable.js can also fetch data from external sources, such as a GeoJSON file, and use it to render the map. By combining Quarto’s document structuring capabilities with Observable.js’s real-time interactivity, you can create analytics documents that not only present your insights but also allow readers to explore data and visualizations dynamically.\nThis Quarto document demonstrates how to create a simple geospatial map using ECharts and display it in an Observable.js cell.\n\n\nCode\nfunction customizeCity(cityData, emphasisColor, itemStyleColor, tooltipFormatter) {\n  return {\n    name: cityData.name,\n    value: cityData.value,\n    itemStyle: {\n      color: itemStyleColor, // Default color is blue\n      borderWidth: 2,\n      borderColor: 'black'\n    },\n    tooltip: {\n        formatter: tooltipFormatter, // Default tooltip format\n    }\n  };\n}\n\nrawData = [\n    {name: 'London', value: [-0.1275, 51.507222]},\n    {name: 'Birmingham', value: [-1.92, 52.48]},\n    {name: 'Manchester', value: [-2.24, 53.48]},\n    {name: 'Leeds', value: [-1.55, 53.79]},\n    {name: 'Glasgow', value: [-4.25, 55.86]},\n    {name: 'Newcastle', value: [-1.6, 54.98]},\n    {name: 'Sheffield', value: [-1.47, 53.38]},\n    {name: 'Liverpool', value: [-2.97, 53.4]},\n    {name: 'Bristol', value: [-2.58, 51.45]},\n    {name: 'Belfast', value: [-5.93, 54.6]},\n    { name: 'Cairo', value: [31.2357, 30.0444] },\n    { name: 'Lagos', value: [3.3792, 6.5244] },\n    { name: 'Nairobi', value: [36.8219, -1.2921] },\n    { name: 'Johannesburg', value: [28.0473, -26.2041] },\n    { name: 'Cape Town', value: [18.4241, -33.9249] },\n    { name: 'Casablanca', value: [-7.6114, 33.5731] },\n    { name: 'Accra', value: [-0.186964, 5.603717] },\n    { name: 'Nairobi', value: [36.8219, -1.2921] },\n    { name: 'Khartoum', value: [32.5549, 15.5007] },\n    { name: 'Abuja', value: [7.49508, 9.05785] }\n                \n]\n\ncities = rawData.map(city =&gt; customizeCity(city, 'green', 'red', `${city.name} - Population: 1000`));\n\n\necharts = require(\"https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.js\")\nrootDiv = html`&lt;div id=\"main\" style=\"width: 800px;height: 800px;\"&gt;&lt;/div&gt;`\nmyChart = echarts.init(rootDiv);\nconsole.log(echarts.api)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n{   \n    const data =  await FileAttachment(\"assets/the-worlds-oceans.geojson\").json();\n    echarts.registerMap('WORLD', data);\n    const option = {\n        tooltip: {},\n        title: {\n            text: 'UK Population Density',\n            subtext: 'Data from 2011 census',\n            left: 'center'\n        },\n        backgroundColor: '#fff',\n        darkMode: true,\n        geo: {\n            map: 'WORLD',\n            roam: true,\n            zoom: 1.2,\n            tooltip: {\n                show: true,\n            },\n            boundingCoords: [\n                [-180, 90],\n                [180, -90]\n            ],\n            emphasis: {\n                label: {\n                    show: true,\n                    color: \"#342FB4\"\n                },\n                itemStyle: {\n                    borderColor: \"#2FB42F\",\n                    borderWidth: 1,\n                },\n                // focus: 'self'\n\n                \n            },\n            itemStyle: {\n                borderColor: \"#000\",\n                color: \"#000\",\n                \n            },\n            \n        },\n\n        series: [\n            {\n                type: 'custom',\n                coordinateSystem: 'geo',\n                data: cities,\n                renderItem: function (params, api) {\n                    console.log(params)\n                    console.log(api)\n\n                    const coord = api.coord([\n                        api.value(0, params.dataIndex),\n                        api.value(1, params.dataIndex)\n                    ]);\n                    return {\n                        type: 'path',\n                        x: coord[0],\n                        y: coord[1],\n                        shape: {\n                            d: 'M16 0c-5.523 0-10 4.477-10 10 0 10 10 22 10 22s10-12 10-22c0-5.523-4.477-10-10-10zM16 16c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686 6 6-2.686 6-6 6z',\n                            x: -10,\n                            y: -35,\n                            width: 20,\n                            height: 40\n                        },\n\n                        emphasis:{\n                            itemStyle: {\n                                borderWidth: 3,\n                                borderColor: 'grey',\n                                shadowBlur: 10,\n                            \n                            },\n                            style: {\n                                shadowBlur: 10,\n                                shadowColor: \"red\"\n                            }\n                        } ,\n                        style: api.style({\n                            fill: api.visual('color'),\n                            stroke: api.visual('borderColor'),\n                            lineWidth: 1,\n                            shadowBlur: 2,\n                            shadowColor: '#000'\n                        }),\n                        \n                    };\n                },\n                \n\n                \n            },\n            \n        ]\n    };\n   \n    myChart.setOption(option);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "stories/exampleStory2.html",
    "href": "stories/exampleStory2.html",
    "title": "Another visualisation",
    "section": "",
    "text": "```{ojs}\nscrolly = require('@ihmeuw/scrollyteller@1.0.2')\n\n// Sections\n// Each section contains a configuration object that encapsulates: \n//  - narration (the scrolling text boxes that narrate the story), \n//  - data, \n//  - graph rendering code, \n//  - event handling code to trigger graph events when narration scrolls into view\nintro = ({\n  sectionIdentifier: 'intro', \n  \n  // 1) Data paths\n  // 2) Render functions\n  // 3) Event handlers \n});\n\n// Section Config Object\nwealthAndHealth = ({\n  // this section will be built in &lt;div id=\"section_wealthAndHealth /&gt;, and the graph will be contained within: &lt;div id=\"graph_wealthAndHealth\" /&gt;\n  \n  sectionIdentifier: 'wealthAndHealth',\n    \n  // 1) DATA PATHS/PROMISES\n  \n  narration: 'path/to/narration.csv',\n  rawData: 'path/to/wealthAndHealthData.json',\n    // on storyInstance.render()...\n    /* after fetching narration... \n      ↘\n          ScrollyTeller renders narration as HTML */\n    /* after fetching data... \n                ↘  raw data is passed to   reshape data function*/\n    \n  // 2) FIRST RENDER FUNCTIONS\n  \n  // Once the DOM elements exist, reshapeDataFunction() is passed the results of the data fetch (rawData)\n  reshapeDataFunction: function (rawData){ \n    // compute data domains for income (x), life expectancy (y), and years\n      const xDomain = getXDomain(rawData); // min, max of all income [300, 100000]\n      const yDomain = getYDomain(rawData); // min, max of life expectancy [30, 80]\n      const yearDomain = getYearDomain(rawData); // min, max of years [1950, 2008]\n \n      // sectionConfig.data in subsequent functions \n      //  return the results of the data as an object with some useful properties\n      // This result is attached to a sectionConfig.data property that is passed to subsequent functions for easy access.\n      return ({\n        dataArray: rawData,\n        xDomain,\n        yDomain,\n        yearDomain,\n      });\n  },\n  \n  //  builds the chart/s for the section\n  // graphId is the id of the div to target to build the graph\n  // sectionConfig is an object containing a variety of props --&gt; the data prop, which is the return value of reshapeDataFunction\n  buildGraphFunction: function (graphId, sectionConfig){\n    /* select graphId, build graph, render graph  */ \n    \n     // destructure the data from reshapeDataFunction() from the sectionConfig\n     // use some object destructuring (ES6 fanciness) to get data props from sectionConfig.data\n      const {\n        data: { dataArray, /* domains, other props, etc */ },\n      } = sectionConfig;\n \n      // build the graph component with the data\n      // create an instance of a custom component called WealthAndHealthOfNations\n      // takes a CSS selector to target the fraphID div and build graph using data and properties calculated in reshapeData function\n      graph = new WealthAndHealthOfNations({\n        container: \"#\" + graphId, // '#graph_wealthAndHealth'\n        data: dataArray, // pass data to the component\n        // ... pass domains, other rendering props, etc\n      });\n      \n      return graph;\n      // sectionConfig.graph in subsequent functions \n  },\n    /*\n        ↘  returned graph instance is stored in\n              ↘ sectionConfig: { data, graph }\n                        ... and is passed to event handlers */\n                        \n  // 3) ON USER EVENT FUNCTIONS\n  \n  // Detect when a narration block becomes active -- using scrollama, active when block intersects middle of page\n  // -&gt; sectionConfig.graph: the return value of buildGraphFunction()\n  // -&gt; state : JSON.parse(trigger),in this case the year\n  onActivateNarrationFunction: function  ({ sectionConfig: { graph }, state: { year }, }){\n    if (graph && year) {\n      graph.render({ year });\n    }\n  },\n  \n  // continuously handle scroll progress \n  // progress: scroll progress\n  // yearDomain: [1950, 1999]\n  onScrollFunction: ({ progress, sectionConfig: { graph }, state: { yearDomain } }){\n    if (graph && yearDomain) {\n    // interpolate years with progress \n      interpolateYear = d3.interpolate(yearDomain[0], yearDomain[1])(progress);\n      year = Math.floor(interpolateYear);\n      graph.render({ year });\n    }\n  },\n  \n  // Triggered when EITHER the window resizes OR when the graph container resizes\n  // Graph container resizes can occur for various reasons, so check to make sure that the resize function isn't being called more often than you would expect.\n  onResizeFunction: function ({ data, graph }) {},\n});\n\n// Story Config object, contains 2 properties\n// 1) an appContainerId, which defines the div id to render the scrolling content into\n// 2) a sectionList object that contains configurations for each of the different sections.\nstoryConfig = ({\n  appContainerId: \"app\", // div id=\"app\"\n  \n  sectionList: [intro, wealthAndHealth, ], // section configuration\n});\n\n// Rendering the story \nstoryInstance = new scrolly.default({storyConfig});\n\n// fetch data and build HMTL\nstoryInstance.render(); \n\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 106, column 84)Unexpected token"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html",
    "href": "stories/ecoAssetsDataStory.html",
    "title": "EcoAssets",
    "section": "",
    "text": "What is EcoAssets\n\n\n\nBubble graph of organisations\n\nPLOT 1: Bubble graph of data contribution by ALA, IMOS, TERN"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-1",
    "href": "stories/ecoAssetsDataStory.html#section-1",
    "title": "EcoAssets",
    "section": "Section 1",
    "text": "Section 1\n\n\nWhat is EcoAssets?\n\n\n\nBubble graph of organisations\n\nPLOT 1: Bubble graph of data contribution by ALA, IMOS, TERN"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-2",
    "href": "stories/ecoAssetsDataStory.html#section-2",
    "title": "EcoAssets",
    "section": "Section 2",
    "text": "Section 2\n\n\nThe ALA, IMOS and TERN have been collecting data since … And every year, they collect and publish more and more data…\n\n\n\n\nPLOT 2: Line graph of counts vs years (biodiversity data)"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-3",
    "href": "stories/ecoAssetsDataStory.html#section-3",
    "title": "EcoAssets",
    "section": "Section 3",
    "text": "Section 3\nAnd they have data about …"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-1.5",
    "href": "stories/ecoAssetsDataStory.html#section-1.5",
    "title": "EcoAssets",
    "section": "Section 1.5",
    "text": "Section 1.5\n\n\n\nLet’s break up the page a bit"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#cam-we-start-a-section-here",
    "href": "stories/ecoAssetsDataStory.html#cam-we-start-a-section-here",
    "title": "EcoAssets Data Story",
    "section": "Cam we start a section here?",
    "text": "Cam we start a section here?\n\nAuto-column\n\n\nAuto-column"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-4",
    "href": "stories/ecoAssetsDataStory.html#section-4",
    "title": "EcoAssets",
    "section": "Section 4",
    "text": "Section 4\n\nBiodiversity data"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-5",
    "href": "stories/ecoAssetsDataStory.html#section-5",
    "title": "EcoAssets",
    "section": "Section 5",
    "text": "Section 5\n\n\nAuto-column\n\n\nMonitoring Data\nAuto-column\n\n\nAuto-column"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-6",
    "href": "stories/ecoAssetsDataStory.html#section-6",
    "title": "EcoAssets",
    "section": "Section 6",
    "text": "Section 6\nThe aggregated datasets have been used for environmental reporting\n[Plot]"
  },
  {
    "objectID": "stories/ecoAssetsDataStory.html#section-7",
    "href": "stories/ecoAssetsDataStory.html#section-7",
    "title": "EcoAssets",
    "section": "Section 7",
    "text": "Section 7\nAnd also for more interesting things…"
  }
]